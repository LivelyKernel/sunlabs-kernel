ometa ClamatoParser <: Parser {
	/* ---- recognizing tokens ---- */	
	space = super(#space) | fromTo('"', '"'),
	identifier = letter:x letterOrDigit*:xs -> [x].concat(xs).join(''),
	unaryId = spaces identifier:x ~':' -> x,
	binaryOp = spaces (char:c ?(ClamatoParser.isBinaryChar(c)) -> c)+:cs -> cs.join(''),
	keywordPart = spaces identifier:x ':' -> {x + ':'},
	variable = spaces identifier:x -> {isVariable: true, name: x},
instanceVariable = token('@') identifier:x -> {isVariable: true, isInstance: true, name: '@' + x},

	literal = (stringLiteral | numberLiteral):v -> {isLiteral: true, value: v},
	numberLiteral = ('+' -> 1 | '-' -> {-1} | empty -> 1):sign digit+:ns -> {
		sign * Number(ns.inject('', function(num, ea) { return num + ea })) },
  stringLiteral = '\'' (token('\'\'') -> '\'' | ~'\'' char)*:val '\'' -> val.join(''),


	/* ---- expressions ---- */	
	primary = spaces (variable | instanceVariable | literal | '(' expression:e ')' -> e | block),
	expression = assignment | evaluation,
	assignment = (variable | instanceVariable):vari token(':=') expression:val
	-> {
		isAssignment: true,
		variable: vari,
		value: val
	},
cascade = evaluation (token(';') message)+,

	evaluation = keywordSend,
	message = (keywordMsg | binaryMsg | unaryMsg),
	unarySend =
	primary:rec unaryMsg*:namesAndArgs 
	-> {
			namesAndArgs.inject(rec, function(receiver, nameAndArgs) {
				return {
					isMessage: true,
					messageName: nameAndArgs[0],
					isUnary: true,
					receiver: receiver
				}
		})},
unaryMsg = unaryId:name -> {[name, null]},

	binarySend =
	unarySend:rec binaryMsg*:namesAndArgs
	-> {
			namesAndArgs.inject(rec, function(receiver, nameAndArgs) {
				return {
					isMessage: true,
					messageName: nameAndArgs[0],
					isBinary: true,
					receiver: receiver,
					args: nameAndArgs[1]
				} 
		})},
binaryMsg = binaryOp:msgName unarySend:arg -> {[msgName, [arg]]},

	keywordSend =
	binarySend:rec keywordMsg:nameAndArgs
	-> {
			{
				isMessage: true,
				messageName: nameAndArgs[0],
				args: nameAndArgs[1],
				isKeyword: true,
				receiver: rec}
			}
		| binarySend,
keywordMsg =
	(keywordPart:keyword binarySend:arg -> [keyword, arg])+:partsAndArgs
	-> {
		var name = '';
		var args = [];
		partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
		[name, args];
	},

block =
	token('[')
	opt(#blockArgs):args
	opt(#declaredVars):declared
	opt(#sequence):s
	token(']')
	-> {
		isBlock: true,
		sequence: s,
		args: args,
		declaredVars: declared
	},
blockArgs = (token(':') variable:v -> v)+:vars token('|') -> vars,


	/* method related */
	sequence = (expression:e ( token('.') | empty ) -> e)+:exprs -> {isSequence: true, children: exprs},
	declaredVars = token('|') (variable:v)*:vars token('|') -> vars,
	clamatoMethod =
	spaces ('-' -> false | '+' -> true):isMeta
	methodNameAndArgs:nameAndArgs
	(primitiveBody | stMethodBody):methodNode
	-> {
			methodNode.isMethod = true;
			methodNode.methodName = nameAndArgs[0];
			methodNode.args = nameAndArgs[1];
			methodNode.isMeta = isMeta;
			methodNode
	},
stMethodBody = opt(#declaredVars):vars opt(#sequence):seq
	-> {
		declaredVars: vars,
		sequence: seq
	},
primitiveBody =
	token('{') -> {$elf.count = 0}
	( ~'}' char:c -> {if (c=='{') $elf.count++; c} | ?($elf.count > 0) token('}'):t -> {$elf.count--; t}
	)*:body
	token('}') (token('.') | empty)
	-> { 
		isPrimitive: true,
		primitiveBody: '{' + body.join('') + '}' 
	},


methodNameAndArgs =
	( (keywordPart:keyword spaces identifier:arg -> [keyword, arg])+:partsAndArgs
		-> {var name = ''; var args = [];
			partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
			[name, args]}
	| binaryOp:msgName spaces identifier:arg -> [msgName, [arg]]
	| unaryId:msgName -> [msgName, null]
	),

	/* ---- class related ---- */
	clamatoClass = token('<') identifier:name token('>') spaces clamatoMethod*:ms
		-> {
			isClass: true,
			className: name,
			methods: ms
		},
clamatoClasses = (clamatoClass)*:cls spaces end -> cls,

	/* ---- helper ----- */
	opt:rule = apply(rule) | empty -> null,
	fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 
	log:x -> {console.log(x); true}
}

ClamatoParser.isBinaryChar = function(c) {
  	// from Squeak's TypeTable
  	var x = c.charCodeAt(0);
  	return (x >= 1 && x <= 8) || x == 11 || (x >= 14 && x <= 29) || x == 31 || x == 33 || x == 37 ||
  	x == 38 || (x >= 42 && x <= 45) || x == 47 || (x >= 60 && x <= 64) || x == 92 || x == 96 ||
  	 ( x >= 126 && x <= 191) || x == 215 || x == 247 || x == 256
}