ometa ClamatoParser <: Parser {
  
/*-----------------------------
----- recognizing tokens ------
------------------------------*/	
space =
  super(#space) | fromTo('"', '"'),
  
identifier =
  letter:x letterOrDigit*:xs
  -> [x].concat(xs).join(''),

unaryId =
  spaces identifier:x ~':'
  -> x,

binaryOp =
  spaces (char:c ?(ClamatoParser.isBinaryChar(c)) -> c)+:cs
  -> cs.join(''),
  
keywordPart =
  spaces identifier:x ':'
  -> {x + ':'},

variable =
  spaces identifier:name
  -> { new StVariableNode(name) },

instanceVariable =
  token('@') identifier:name
  -> { new StInstanceVariableNode('@' + name) },

literal =
  (stringLiteral | numberLiteral):v
  -> { new StLiteralNode(v) },

numberLiteral =
  ('+' -> 1 | '-' -> {-1} | empty -> 1):sign digit+:ns
  -> {sign * Number(ns.inject('', function(num, ea) { return num + ea })) },

stringLiteral =
  '\'' (token('\'\'') -> '\'' | ~'\'' char)*:val '\''
  -> val.join(''),

/*-----------------------------
--------- expressions ---------
------------------------------*/
primary =
  spaces (variable
        | instanceVariable
        | literal
        | '(' expression:e ')' -> e
        | block),

expression =
  cascade | assignment | evaluation,

assignment =
  (variable | instanceVariable):variable token(':=') expression:value
	-> { new StAssignmentNode(variable, value) },

cascade =
	evaluation:first (token(';') message)+:msgNodes
	-> {
		if (!first.isMessage) throw(new Error('First part of cascade not message'));
		var receiver = first.receiver;
		msgNodes = [first].concat(msgNodes);
		msgNodes.forEach(function(ea) { ea.receiver = receiver });
		new StCascadeNode(msgNodes, receiver);
	},

evaluation =
  keywordSend,

message =
  (keywordMsg | binaryMsg | unaryMsg),

unarySend =
  primary:rec unaryMsg*:msgNodes
	-> {msgNodes.inject(rec, function(receiver, node) {
	    node.setReceiver(receiver); return node }) },

unaryMsg =
	unaryId:name
	-> { new StUnaryMessageNode(name, null, null) },

binarySend =
	unarySend:rec binaryMsg*:nodes
	-> { nodes.inject(rec, function(receiver, node) {
		node.setReceiver(receiver); return node }) },

binaryMsg =
	binaryOp:name unarySend:arg
	-> { new StBinaryMessageNode(name, [arg], null) },

keywordSend =
	binarySend:rec keywordMsg:msgNode
	-> { msgNode.setReceiver(rec); msgNode }
	| binarySend,

keywordMsg =
	(keywordPart:keyword binarySend:arg -> [keyword, arg])+:partsAndArgs
	-> {
		var name = '', args = [];
		partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
		new StKeywordMessageNode(name, args, null);
	},

block =
	token('[')
	opt(#blockArgs):args
	opt(#declaredVars):declared
	opt(#sequence):s
	token(']')
	-> { new StBlockNode(s, args, declared) },

blockArgs =
	(token(':') variable:v -> v)+:vars token('|')
	-> vars,

/*-----------------------------
------- method related  -------
------------------------------*/
sequence =
  (expression:e ( token('.') | empty ) -> e)+:children
  -> { new StSequenceNode(children) },

declaredVars =
  token('|') (variable:v)*:vars token('|')
  -> vars,

clamatoMethod =
	spaces ('-' -> false | '+' -> true):isMeta
	methodNameAndArgs:nameAndArgs (primitiveBody | stMethodBody):methodNode
	-> {
		methodNode.setMethodName(nameAndArgs[0]);
		methodNode.setArgs(nameAndArgs[1]);
		methodNode.setMeta(isMeta);
		methodNode
	},

stMethodBody =
  opt(#declaredVars):vars opt(#sequence):seq
	-> { new StMethodNode(null, null, null, seq, vars) },

primitiveBody =
	token('{') -> {$elf.count = 0}
	( ~'}' char:c -> {if (c=='{') $elf.count++; c} | ?($elf.count > 0) token('}'):t -> {$elf.count--; t}
	)*:body
	token('}') (token('.') | empty)
	-> { new StPrimitveMethodNode(null, null, null, '{' + body.join('') + '}') },


methodNameAndArgs =
	((keywordPart:keyword spaces identifier:arg -> [keyword, arg])+:partsAndArgs
		-> {var name = ''; var args = [];
			partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
			[name, args]}
	| binaryOp:msgName spaces identifier:arg -> [msgName, [arg]]
	| unaryId:msgName -> [msgName, null]
	),

/*-----------------------------
-------- class related  -------
------------------------------*/
clamatoClass =
	token('<') identifier:name token('>') spaces clamatoMethod*:methods
	-> { new StClassNode(name, methods) },

clamatoClasses =
	(clamatoClass)*:cls spaces end -> cls,

/*-----------------------------
------------ helper  ----------
------------------------------*/
opt:rule =
	apply(rule) | empty -> null,

fromTo :x :y =
	seq(x) (~seq(y) char)* seq(y),

log:x
	-> {console.log(x); true}
}

/* ----------- additional stuff ----------------*/

ClamatoParser.isBinaryChar = function(c) {
  	// from Squeak's TypeTable
  	var x = c.charCodeAt(0);
  	return (x >= 1 && x <= 8) || x == 11 || (x >= 14 && x <= 29) || x == 31 || x == 33 || x == 37 ||
  	x == 38 || (x >= 42 && x <= 45) || x == 47 || (x >= 60 && x <= 64) || x == 92 || x == 96 ||
  	 ( x >= 126 && x <= 191) || x == 215 || x == 247 || x == 256
}

/* ----------- JS2St translation ----------------*/

ometa JS2StConverter {
trans      = [:t apply(t):ans]     -> ans,
/* ----------- copied -------------- */
get      :x                                           -> x,
string   :s                                           -> s.toProgramString(),
begin    trans:x end                                  -> x,
/* ---------- modified ----------- */
json     trans*:props                                 -> props,
/* ------------ own -------------- */
send :msg ?(msg == 'subclass') trans:superclass trans:name trans:body -> {new StClassNode(name, body, superclass)},
	test -> StClassNode
}