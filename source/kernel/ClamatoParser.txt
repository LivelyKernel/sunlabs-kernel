ometa ClamatoParser <: Parser {
	/* helper */
	opt:rule = apply(rule) | empty -> null,
fromTo :x :y = seq(x) (~seq(y) char)* seq(y), 

	/* ---- recognizing tokens ---- */	
	space = super(#space) | fromTo('"', '"'),
	identifier = letter:x letterOrDigit*:xs -> [x].concat(xs).join(''),
	unaryId = spaces identifier:x ~':' -> x,
	binaryOp = spaces (char:c ?(ClamatoParser.isBinaryChar(c)) -> c)+:cs -> cs.join(''),
	keywordPart = spaces identifier:x ':' -> {x + ':'},
	variable = spaces identifier:x -> {isVariable: true, name: x},
instanceVariable = token('@') identifier:x -> {isVariable: true, isInstance: true, name: '@' + x},

	literal = (stringLiteral | numberLiteral):v -> {isLiteral: true, value: v},
	numberLiteral = ('+' -> 1 | '-' -> {-1} | empty -> 1):sign digit+:ns -> {
		sign * Number(ns.inject('', function(num, ea) { return num + ea })) },
  stringLiteral = '\'' (token('\'\'') -> '\'' | ~'\'' char)+:val '\'' -> val.join(''),


	/* ---- expressions ---- */	
	primary = spaces (variable | instanceVariable | literal | '(' expression:e ')' -> e | block),
	expression = assignment | evaluation,
	assignment = (variable | instanceVariable):vari token(':=') expression:val
	-> {
		isAssignment: true,
		variable: vari,
		value: val
	},
	evaluation = keywordMsg,
	messageSend = (unaryMsg | binaryMsg | keywordMsg):node -> {node.isMessage = true; node},
	unaryMsg = primary:rec (unaryId:msgName)*:msgs 	-> {
						msgs.inject(rec, function(receiver, mName) {
							return {
								isMessage: true,
								messageName: mName,
								isUnary: true,
								receiver: receiver
							} })},
	binaryMsg = unaryMsg:rec (binaryOp:msgName unaryMsg:arg -> [msgName, [arg]])*:msgs -> {
						msgs.inject(rec, function(receiver, mNameAndArgs) {
							return {
								isMessage: true,
								messageName: mNameAndArgs[0],
								isBinary: true,
								receiver: receiver,
								args: mNameAndArgs[1]
							} })},
	keywordMsg = binaryMsg:rec (keywordPart:keyword binaryMsg:arg -> [keyword, arg])+:partsAndArgs -> {
		var name = ''; var args = []; partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
		{isMessage: true, messageName: name, args: args, isKeyword: true, receiver: rec}}
						| binaryMsg,
block = token('[') opt(#blockArgs):args opt(#declaredVars):declared opt(#sequence):s token(']') ->
	{isBlock: true, sequence: s, args: args, declaredVars: declared},
blockArgs = (token(':') variable:v -> v)+:vars token('|') -> vars,


	/* method related */
	sequence = (expression:e ( token('.') | empty ) -> e)+:exprs -> {isSequence: true, children: exprs},
	declaredVars = token('|') (variable:v)*:vars token('|') -> vars,
	clamatoMethod =
	token('-')
	methodNameAndArgs:nameAndArgs
	opt(#declaredVars):vars
	opt(#sequence):seq
	-> {
			isMethod: true,
			methodName: nameAndArgs[0],
			args: nameAndArgs[1],
			declaredVars: vars,
			sequence: seq
	},
methodNameAndArgs =
	( (keywordPart:keyword spaces identifier:arg -> [keyword, arg])+:partsAndArgs
		-> {var name = ''; var args = [];
			partsAndArgs.forEach(function(ea) { name += ea[0]; args.push(ea[1]) });
			[name, args]}
	| binaryOp:msgName spaces identifier:arg -> [msgName, [arg]]
	| unaryId:msgName -> [msgName, null]
	),



	/* ---- helper ----- */
	log:x -> {console.log(x); true}
}

ClamatoParser.isBinaryChar = function(c) {
  	// from Squeak's TypeTable
  	var x = c.charCodeAt(0);
  	return (x >= 1 && x <= 8) || x == 11 || (x >= 14 && x <= 29) || x == 31 || x == 33 || x == 37 ||
  	x == 38 || (x >= 42 && x <= 45) || x == 47 || (x >= 60 && x <= 64) || x == 92 || x == 96 ||
  	 ( x >= 126 && x <= 191) || x == 215 || x == 247 || x == 256
}