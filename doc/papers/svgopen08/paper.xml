<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0b5/rng/docbook.rng" type="xml"?>
<?xml-stylesheet type="text/xsl" href="http://docbook.sourceforge.net/release/xsl/current/xhtml/docbook.xsl"?>

<!-- 
     Safari will load this file and honor the stylesheet spec above.
     Alternatively, a simple, slow, offline way of generating html from the command line:

     $ xsltproc http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl paper.xml > paper.html.

-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>The Lively Kernel Application Framework</title>
<!--    <subtitle></subtitle> -->
    <keywordset>
      <keyword>SVG</keyword>
      <keyword>GUI Frameworks</keyword>
      <keyword>Web Applications</keyword>
    </keywordset>
    <authorgroup>
    <author>
      <personname>
        <firstname>Krzysztof</firstname>
        <surname>Palacz</surname>
      </personname>
      <email>krzysztof.palacz@sun.com</email>
      <!-- <personblurb><para>Krzysztof Palacz is blah blah</para></personblurb>  -->
      <affiliation>
	<!--        <jobtitle>Staff Engineer</jobtitle> -->
        <org>
          <orgname>Sun Microsystems Laboratories</orgname>
	  <!--          <orgdiv></orgdiv> -->
          <address>
            <city>Menlo Park</city>
            <street>16 Network Circle</street>
	    <postcode>94025</postcode> 
	    <state>CA</state>
	    <country>USA</country>
          </address>   
        </org>
      </affiliation>
      
    </author>
    <author>
      <personname> <firstname>Dan</firstname> <surname>Ingalls</surname> </personname>
      <email>dan.ingalls@sun.com</email>
    </author>
    </authorgroup>

    <abstract>
      <para>
	
The Lively Kernel is a fully interactive, "zero-installation"
Web application framework and development environment and written
entirely in JavaScript. The rich user experience of applications built
using the Lively Kernel is enabled by integrated programmatic access
to arbitrary, dynamic 2D graphics, and owed in no small part to its
reliance on Scalable Vector Graphics and its bindings to the
JavaScript language.
</para>

<para>
Lively Kernel runs in SVG-enabled Web browsers without installation or
plug-in requirements; it offers a compact and extensible set of user
interface components, as a result, it supports familiar desktop-style
applications with the expected user interface functionality and direct
manipulation capabilities; it enables application development and
deployment in a Web browser with no installation or upgrades, using
only existing Web technologies. In addition to its application
execution capabilities, the Lively Kernel also functions as an
integrated development environment (IDE), as a result, it is
self-supporting and able to improve and extend itself
dynamically. Lively Kernel is currently also one of the most sizable
dynamic SVG frameworks available, and has become an important test
case for SVG implementations in Web browsers.
</para>

<para>
The main component of the Lively Kernel is a user interface framework
called Morphic, originally developed for the Self language, and later
incorporated into Squeak (a version of the Smalltalk programming
language). The Morphic framework consists of about 10,000 lines of
uncompressed JavaScript code downloaded to the Web browser on Lively
Kernel startup. The central goal of Morphic is to facilitate
construction and editing of graphical objects, both programmatically
and by direct, interactive manipulation. Morphic objects are editable,
composable and animatable, Morphic also handles user input and manages
underlying system resources such as fonts, gradients or
images. Built-in mechanisms are provided for object scaling, rotation,
object editing, as well as for defining user interface
themes. Currently, visual editing tools are provided for only a subset
of the elements defined in the SVG specification, however, our system
could be straightforwardly extended to act as a complete SVG authoring
tool.
</para>

<para>
The Morphic framework also provides a library of higher level user
interface components, such as buttons, lists, menus, windows, etc.,
composed from the basic graphical objects, as well as a
Model-View-Controller infrastructure for abstracting visual
representation of data from application logic. The default
configuration of the Lively Kernel offers a familiar desktop metaphor
with multiple applications running concurrently, however, standalone
applications are also supported.
</para>

<para>
The Morphic framework includes tools for development, modification and
deployment of applications from within the Lively Kernel system
itself. The tools include a class browser, an object inspector and a
DOM inspector. The implementation of these tools relies on the
reflective capabilities of JavaScript, and can therefore be used
inside the Web browser without any external tools or IDEs. As a
result, it is possible to, e.g., create new JavaScript classes, modify
or delete existing methods, or change the value of any property in the
system. Finally, it is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
</para>
</abstract>
</info>
<section>

<title>The Lively Kernel approach to Rich Internet Applications</title>



<para>
The explosive growth of the Internet and growing interest in expanding
interactive functionality and usability of Web applications has
recently sparked a revival of sorts of graphical user interface (GUI)
framework development. The cross-platform, standards-oriented nature
of enabling technologies available in commercial Web browsers lowered
the barrier of entry to the field of GUI framework development, and
greatly reduced the dependence on operating system vendors and their
software distribution and update channels. As a result, a variety of
popular, actively developed Web-based GUI frameworks have sprung up,
usually as main components of so called <emphasis>AJAX</emphasis>
toolkits, which leverage the JavaScript language, dynamically updated
HTML markup and asynchronous XML requests to provide rich user
experience. On the other hand, vendors such as Adobe and Microsoft
recognize the limitations of technologies implemented by Web browsers,
and promote proprietary frameworks based on external runtimes
available as browser plug-ins, such as Adobe Flash, Adobe Flex and
Microsoft Silverlight.
</para>


<para>
Naturally, currently available AJAX toolkits aim to reproduce the
functionality and usability of a modern desktop GUI framework. In this
paper we present an alternative approach, a system that capitalizes on
decades of GUI research and innovation outside the mainstream practice
of GUI framework design. The renewed interest in GUI frameworks
presents itself as a unique opportunity to advance the state of art
and offer these results to wider audiences.
</para>

<!-- The alternatives are: Reproduce a typical desktop environment, or jump
forward, capitalize on decades of GUI research and innovation outside
of the desktop mainstream. Multiple very impressive and advanced AJAX
GUI toolkits attempt to emulate modern desktop environments, 
Unique opportunity to improve the state of art.
-->


<remark>
<para>
The main difference is a much higher level of dynamicity and
malleability, offered equally to the programmer and to the interactive
user. Our system is called Lively Kernel, to emphasize both the intent
to apply the notions of read-write Web to graphics programming, and 
</para>


<para>
LK aims to improve both functionality and developer-visible software
architecture at the same time.  The base choice of the JavaScript
language in typical AJAX environments is fortunate for our goals
because the language is highly dynamic. The basic choice of the
graphics substrate is not. While the existing AJAX toolkits achieve
wonders by building on top the text markup infrastructure (HTML) not
originally meant to support rich user experiences, LK in its current
form builds on SVG and its rich graphics model is a much better
foundation.  
</para>

<para>
LK presents traditional procedural API, SVG used almost exclusively
through the DOM interface, low level markup eliminated from the
programmers interface (although accessible underneath).  Resulting
system is both compact (10,000 LOC w/comments) and expressive.  A
natural graphics API enables LK to be a web programming kernel,
compact and comprehensible for a single programmer, based on single
syntax and semantics (javascript) while the other AJAX toolkits often
require a lot of mental context switching among Javascript, HTML, CSS
and other auxiliary technologies.

</para>

<para>
our system more than capable of implementing traditional desktop
metaphors, as shown in <xref linkend="fig_desktop"/>, yet not limited to it.
</para>
 </remark>



<figure xml:id="fig_desktop">
<title>Lively Kernel desktop</title>
<mediaobject><imageobject>
<imagedata fileref="screenshot-small.jpg"/>
</imageobject></mediaobject>
<caption><para>Example instantiation of the Lively Kernel.</para></caption>
</figure>
<para>
This paper presents the SVG backend of the Lively Kernel. We have
found the SVG standard to be a great fit as our graphics substrate,
and its implementations in widely available Web browsers turned out to
 be adequate to demonstrate the potential of our approach. While our
current work is almost exclusively built on top of the SVG backend, we
are vitally interested in portability to other graphics substrates.
In fact, an earlier version of our system provided a custom
browser-like environment on top of the Java platform, using Java2D
APIs as its graphics subsystem and Rhino as its execution engine.
</para>

</section>

<section>

<title>Morphic User Interface Framework</title>

<para>
The majority of the JavaScript classes defined by the Lively Kernel
are related to a user interface framework called Morphic.  The Morphic
framework was developed originally for the Self language and system
(<link xlink:href="http://research.sun.com/self" />), and later became popular
as the user interface of the Squeak system
(<link xlink:href="http://www.squeak.org"/>). Lively Kernel reimplements a
sizable subset of the original Morphic framework using technologies
available in modern web browsers.
</para>

<para>
Morphic achieves simplicity and uniformity of programmatic and
interactive constuction and manipulation of graphical objects by
defining and extensively relying on a class of graphical objects
called “morphs”, possessing some or all of the following properties:
<itemizedlist mark="bullet">
  <listitem> <para>
      A shape, or graphical appearance,
  </para> </listitem>
  <listitem> <para>
      A set of submorphs, comprising the “scene graph” of the page or world,
  </para> </listitem>
  <listitem> <para>
      A coordinate transformation that affects its shape and any submorphs,
  </para> </listitem>
  <listitem> <para>
      An event handler for mouse and keyboard events,
  </para> </listitem>
  <listitem> <para>
      An editor for changing its shape,
  </para> </listitem>
  <listitem> <para>
      A layout manager for laying out its submorphs,
  </para> </listitem>
  <listitem> <para>
      A stepping protocol for time-varying behavior,
  </para> </listitem>
  <listitem> <para> A damage rectangle repainting protocol and
      double-buffered display mechanism (used when the underlying
      graphics substrate does not provide it).
  </para> </listitem>
</itemizedlist>
</para>

<para>
Morphic defines several classes of morphs with special semantics.
A <code>WorldMorph</code> captures the notion of an entire web page;
its shape defines its background appearance, if any, and its submorphs
comprise all the remaining content of the page. In contrast to typical
web pages, however, multiple worlds can coexist in a single JavaScript
execution context. Notionally, the user interacts with the contents of
single world, and navigates between different worlds by clicking on
<code>LinkMorphs</code>, representing of connections between worlds.
</para>

<para>
A <code>HandMorph</code> is the Morphic generalization of a cursor; it can be used
to pick up, move, and deposit other morphs, its shape may change to
indicate different cursor states, and it is the source of user events
in the architecture.  In Lively Kernel, a Morphic world may have
several hands active at the same time, corresponding to several
collaborating users of that world (this functionality is not yet
available in the current incarnation of the Lively Kernel, however, it
has been implemented in the previousy mentioned earlier prototype
based on the Java platform).
</para>

</section>

<section>
<title>A Lively Construction</title>
<para>
Morphic provides means of interactive manipulation of morphs included
in the framework, and, transitively, composite morphs assembled from
the morphs already in existence.  In contrast with the mostly static
elements of typical Web pages, each morph in a Lively Kernel world can
be picked up, moved, resized, rotated, duplicated and reshaped. Thus,
at its simplest, the Lively Kernel functions as a rudimentary graphics
editor.
<remark>most of LK can be viewed as an editor for something or other</remark>
</para>

<para>

The sequence shown in Figure <xref linkend="fig_construction"/>
illustrates the construction of a simple truck shape by concrete
manipulation. In Figure a we see a palette of useful shapes.  In
Figure b, the rectangle has been copied, and extended in Figure c.  In
Figure d, the rectangle has been colored yellow, an ellipse has been
copied, resized, and colored, and has been given a thick black border
to resemble a tire, and a second copy has already been affixed to the
bus.  In Figure e, the truck is complete, and Figure f shows a family
of trucks, copied and rotated from the new master, all operations that
can be accomplished with simple gestures in the Lively Kernel's
graphic editor.
</para>


<figure xml:id="fig_construction">
<para>

<mediaobject>
<imageobject><imagedata fileref="construction-a.png"/> </imageobject>
<textobject><phrase>a</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject><imagedata fileref="construction-b.png"/></imageobject>
<textobject><phrase>b</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-c.png"/></imageobject>
<textobject><phrase>c</phrase></textobject>
</mediaobject>
</para>
<para>

<mediaobject>
<imageobject> <imagedata fileref="construction-d.png"/></imageobject>
<textobject><phrase>d</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-e.png"/></imageobject>
<textobject><phrase>e</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-f.png"/></imageobject>
<textobject><phrase>f</phrase></textobject>
</mediaobject>
<caption>Drag and drop construction of simple objects in the Lively Kernel</caption>
</para>

</figure>


<!--Extending the graphical vocabulary  -->
<para>
<figure xml:id="fig_spiral">
<title>Extending the graphical vocabulary</title>
<mediaobject><imageobject>
<imagedata fileref="spiral.png"/>
</imageobject></mediaobject>
<caption><para>The red spiral on the left hand side is a morph created
programmatically by the code contained in the rectangle on the
right. The orange spiral in the center is derived from it by
interactive manipulation.</para></caption>
</figure>
</para>
<para>
Beyond the basic vocabulary of the underlying graphics support, the
programmability of Morphic shapes provides an unlimited range of
graphical idioms.  Figure <xref linkend="fig_spiral"/> shows a small
snippet of JavaScript that draws a polygonal spiral.  Beyond mere
marks on the screen, this code produces a fully active object that can
be copied, scaled, and colored, as shown, and that could be set to
spinning with one more line of code, such as
<programlisting><![CDATA[
this.startStepping(50, “rotateBy”, 0.1); // 0.1 radians every 50 ms
]]></programlisting>
</para>


</section>
<section><title>Simple Editors</title>

<figure xml:id="fig_editors">
<title>Editor</title>
<mediaobject><imageobject>
<imagedata fileref="editors.gif"/>
</imageobject></mediaobject>
<caption><para>A SelectionMorph (left) and a HandleMorph (the blue rectangle on the polygon; shown with balloon help). <remark>FIXME better pic</remark> </para></caption>
</figure>



<remark>

<para>
Editors implemented as morphs, in particular shape editors are
instances of <code>HandleMorphs</code> and expose user interface
bindings for resizing, rotating, reshaping, rotating of the target
morph. Morphic also provides other editor morphs, among
them <code>ColorPickerMorph</code>, used to select and apply solid
colors to <code>fill</code> and <code>stroke</code> attributes,
and <code>SelectionMorph</code> (or “selection tray”), which allows
the same operations to be applied to multiple morphs. See Figure
<xref linkend="fig_editors"/>.  Editors are somewhat volatile and
decorate target morphs.
</para>
</remark>


<remark>Make better screenshot, with selection, color picker and handle morph.</remark>

<para>

Our Morphic implementation does not currently provide editors for all
the elements and attributes specified by the SVG standard, however,
such a complete implementation would be feasible, and would constitute
an interesting light-weight, self-sustaining graphics editor for the
web FIXME.

</para>
</section>


<section><title>Editing text</title>
<para>
An editable graphics environment would not be complete without support
for editing text, and Lively Kernel comes with a rich text editor
built into every <code>TextMorph</code>, the basic text container and
unit of text manipulation.  The Lively Kernel provides this
functionality with three basic components:

<itemizedlist mark="bullet">
  <listitem> <para> A rich text model (<code>Text, RunArray, TextEmphasis</code>)</para>
    <para> TextEmphasis is an aggregate property, such
      as <code>{style: 'bold', fontSize: 14}</code>, together with a
      method for merging with other instances.  <code>RunArray</code> is a
      compactly encoded array of <code>TextEmphasis</code> objects corresponding to
      every character of a Text.  Most of the work is associated with
      slicing and concatenating these objects.  An optimization allows
      efficient streaming through what is effectively a sparse
      structure.  Text is nothing more than a String of characters
      with a matching RunArray of emphasis.
    </para>
  </listitem>
  <listitem> 
    <para> A text composition facility (<code>Font, TextWord, TextLine, TextMorph</code>)</para>
    <para> 
      Text composition is a classic problem in computer
      graphics.  It is a process of streaming through the text, noting
      exceptions when emphasis changes, and when the frame boundary or
      mouse location is encountered.  <code>TextLine</code> and <code>TextWord</code> are the
      components that capture the state of this process, and that
      allow efficient display and location of the individual
      characters.
    </para>
  </listitem>
  <listitem> <para> A text editor (<code>TextMorph, TextSelection</code>) </para>
    <para> 
      Once text has been composed, a text editor
      dispatches user events to manipulate the current selection and alter
      either the content or the emphasis of the selected text.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>The totality of the text package in the Lively Kernel is
approximately 2000 lines of JavaScript, including comments.  Lists and
menus are built from it in a further 400 lines.
<remark> not sure of either -- I think 2000 may be without the editor,
and 400 for lists and menus was a guess</remark>
</para>

<para> 
The decision to tackle active text was a daunting one.
Composition of text is the most complex module in the Lively Kernel.
Access to font metrics is complex and browser-dependent, and
character-by-character composition is a challenge even for the faster
JavaScript implementations.  That said, we consider the achievement of
active WYSIWYG text, independent of native widgets, to be a
breakthrough.  In a context such as SVG, arbitrary text and graphics
can now be freely mixed, interactive changes can be made through
arbitrary coordinate transformations, all without concern for
installation barriers or browser-specific text problems.
<remark>
explain why not drop to HTML (both b/c foreignObjects not so well
supported and b/c we want a kernel).
</remark>
</para>

</section>

<section><title>Editing abstract data: widgets and MVC</title>
<remark>
<para>
Editing capabilities not only limited to SVG, but apply (potentially)
to other structured data.
</para>
<figure xml:id="fig_widget">
<title>An example MVC widget.</title>
<mediaobject><imageobject>
<imagedata fileref="mvc-widget.png"/>
</imageobject></mediaobject>
<caption><para>A composite widget comprising multiple Views on parts of the same Model.<remark>emphasize simplicity and conciseness</remark>
</para></caption>
</figure>




<para> MVC style, model is a simple collection of items. Demo
widget. Style editor as an example of a complex widget. Figure of a
demo widget and style editor.</para>
<para> browser for tree-structured data. Figure with a DOM browser
side by side with a file browser. Applicable to SVG DOM but any other
kind of structured data (experimental). Also, potentially,
tree-structured Models. Mention potential relationship to XForms?
</para>

</remark>


</section>

<section><title>Editing source code: development tools</title>
<para>
<figure xml:id="fig_browser">
<title>Class browser.</title>
<mediaobject><imageobject>
<imagedata fileref="browser.png"/>
</imageobject></mediaobject>
<caption><para>Code browser editing executable code for a clock
widget. Saving code results in instant changes to the clock's
behavior. The browser is tilted for no particular reason other than to
show that it's fully functional regardless of the affine transforms
applied to it.</para></caption>
</figure>
</para>



</section>


<section><title>Implementing Morphic in SVG</title> 

<remark> 
<para>the whole SVG tree is built dynamically. By default, the
entry point to the Lively Kernel runtime is a static document defining
only a single empty <code>&lt;svg&gt;</code> element, and the entire
SVG DOM tree of the running system is constructed programmatically
from JavaScript on system load. </para>
<para> 
World maps onto contents of the <code>&lt;svg&gt;</code> element.
</para>
<para>
HandMorph maps to some extent to the <code>&lt;cursor&gt;</code>
element.
</para>

</remark>

<programlisting><![CDATA[
319 Host Interface – Browser API plus XML utility functions 
515 Utility – Classes, collections, printing, etc. (plus 562 in Prototype.js) 
833 Basic Graphics – Point, Rectangle, Transform, Color, Gradient, Image 
550 Shapes – Host graphical objects (SVG node API) 
1667 Morph – Basic protocol 
1170 Morphic Core -- World, Hand, Event, Handles, Handlers 
1188 Basic Widgets – Button, List, Menu, Dialog, Slider, Selection, ImageMorph 
1921 Text – basic TextMorph plus composition and rich text 
747 Editors – Drag/drop manipulation, shape editors and text editing 
also ColorPicker and StylePanel 
386 Model, Widget 
1295 High Level Widgets – Scroll panes, panels, windows, world links 
also Panel and Browser support 
1311 Tools – Browser, inspector, stack viewer, change lists, profiler 
406 Serialization – Copier, exporter, importer (plus 202 in JSON) 
281 Network – URL, HTTP, WebDAV basics 
365 Storage – WebDAV, file browser 
----- ----- 
12954 Total 

Figure 10: Breakdown of Lively Kernel by function with approximate
code size The figures above include comments and lines with single
bracket characters.  Prototype.js is an open source set of useful
JavaScript extensions, of which we use only a small number [see
http://www.prototypejs.org/], [see http://www.JSON.org/].
]]></programlisting>


<!-- Imperative API for SVG, hiding the XML underpinnings and hence
portable to different architectures. API JS-centric (hence no XBL,
even though similar interest in reusable components).
-->

<section>
<title>Containment</title>
<para>The Morphic framework organizes visual objects on the screen
using a tree of morphs. Each morph has a single owner morph and can
act as a container for other morphs. The SVG backend of Lively Kernel
naturally maps morphs onto SVG <code>&lt;g&gt;</code> elements. The
semantics of <code>&lt;g&gt;</code> elements corresponds well to the
semantics of Morphic, specifically, the nesting of
<code>&lt;g&gt;</code> elements is a means of logical organization and
does not imply visual containment, and submorphs are not necessarily
visually contained inside their owner morphs, either. A morph's shape is
represented by one of the basic SVG shape elements, such
as <code>&lt;rect&gt;</code>, <code>&lt;ellipse&gt;</code>,
or <code>&lt;path&gt;</code>.
</para>

<para>Currently, Lively Kernel does not take advantage of the property
inheritance mechanism of <code>&lt;g&gt;</code> elements provided by
the SVG specification, and each basic shape element is required to specify the
full set of its visual attributes. This feature of the SVG standard
could be potentially taken advantage of, both as implementation
technique to improve space utilization, and as an API-level
programming abstraction (perhaps as a mechanism to specify widget
"skins").
</para>
</section>


<para>
The Lively Kernel SVG backend allocates a private
 <code>&lt;defs&gt;</code> element to every morph. The SVG
specification designates <code>&lt;defs&gt;</code> elements as
containers for elements that are not directly rendered on the screen,
such as gradients or clip paths. These elements are typically referred
to by URI attributes on other elements (the SVG standard makes
extensive use of URI references to express relations between elements
that are not captured by the DOM tree hierarchy). This design
facilitates space optimizations through sharing of commonly used
elements, however, Lively Kernel does not currently take advantage of
it. Instead, all the elements in a morph's <code>&lt;defs&gt;</code>
section are notionally owned by the morph, and the URIs of these
elements are trivially derived from the URI of the
morph's <code>&lt;g&gt;</code> element. As a result, every morph
defines all the gradients it uses, even though a typical user
interface uses only a handful of distinct gradient definitions that
could be shared and applied to multiple visual elements. This may be
perceived as a shortcoming of the current SVG backend, however, the
presented technique does simplify certain implementation aspects, most
notably copying and serialization of individual morphs. We envision
that a future version of our system could implement gradient sharing,
most likely through a uniform reference counting facility for all SVG
elements referenced through URIs.
</para>

<!--What does it have to do with Lessphic? -->

<section> 
<title>The implementation of mapping: wrapping versus extending DOM elements</title>
<para>
There are at least two general methods of implementing the mapping
of abstract tree data structures, such as the morph tree defined by
the Morphic API, to DOM trees. The first involves extending
appropriate DOM elements so that they <emphasis>become</emphasis>
morphs. This was the method originally used by the Lively Kernel SVG
backend. Despite its conceptual simplicity, it required certain
non-obvious implementation techniques. For instance, while all morphs
were mapped to <code>&lt;g&gt;</code> elements, the converse was not
deemed appropriate: not all <code>&lt;g&gt;</code> elements should be
morphs. In order to satisfy this requirement, morph factory methods
dynamically modified the inheritance chain of <code>&lt;g&gt;</code>
elements intended to become morphs, by inserting a morph prototype
object, defining the functionality shared by all morphs. Such
modifications are not possible according to the ECMAScript language
specification (an object's <code>prototype</code> is generally not
accessible programmatically), however, most JavaScript implementations
recognize this problem as a language limitation, and make the object
prototype accessible through a mutable <code>__proto__</code> property
that can be manipulated to obtain the desired inheritance
behavior. Unfortunately, this approach eliminated the Opera browser
from the list of potential Lively Kernel platforms, since its
JavaScript engine does not implement <code>__proto__</code>.
</para>

<para>
A minor inconvenience of this approach was that new morphs were
instantiated using factory methods of the form <code>MyMorph()</code>,
instead of explicit allocation syntax, as in <code>new
MyMorph()</code> (as a side note, due to the semantics of JavaScript,
accidental insertion of the <code>new</code> keyword did not affect
the correctness of the program, but merely resulted in a wasteful
allocation of an unused object). A much more important limitation
turned out to be the incompatibility with environments such as Batik
(<xref linkend="Batik" />), which support the <code>__proto__</code> property but
do not allow extension of host objects (i.e., objects created and
managed outside of the JavaScript runtime, such as DOM objects, and
merely exposed programmatically to JavaScript).
</para>

<para>
In the face of the limitations, the subsequent reimplementation of the
Lively Kernel SVG backend uses a more conventional implementation
technique based on <emphasis>wrappers</emphasis>. Morphs are
implemented as regular, user-defined JavaScript objects furnished with
a <code>rawNode</code> property, pointing to the host object
representing the corresponding <code>&lt;g&gt;</code>
element. Similarly, <code>Shape</code> objects wrap simple SVG shape
elements referred to through their <code>rawNode</code> property. No
new properties or methods are added to host objects, and many Morph
and Shape methods simply delegate to the
underlying <code>rawNode</code>. Unfortunately, the object identity of
the Morph is now distinct from the identity of the
underlying <code>rawNode</code>, which requires additional boilerplate
code to map from Morphs to DOM objects. Interestingly, other than
while debugging, it is currently never necessary to find a
corresponding Morph given the DOM element that implements it, is due
largely to the fact that Lively Kernel performs its own mouse event
delivery.

The technique itself is of course well known, in particular the Dojo
toolkit <remark>FIXME cite? </remark> uses a similar approach for its cross-platform graphics
library <code>dojo.gfx</code>, and Lively Kernel even borrows its
convention of naming the underlying DOM element <code>rawNode</code>.
</para>

</section> <!-- end of wrapping vs extending -->


<para>
Lively Kernel does not currently use several features of the SVG
specification. Most notably, it does not use declarative animations,
due to both lack of support in many browsers, and our interest in
portability of the implementation to other graphics backends. Instead,
a simple imperative framework for scheduling and periodic invocation
of user-supplied actions is provided. Document styling (through either
Cascading Style Sheets or Extensible Stylesheet Language standards) is
not currently used, either, although useful applications of styling
could be envisioned. For instance, styling could be used to implement
UI themes, i.e., sets of visually coherent presentation attributes
that can be applied to a widget or application at the user's
discretion. UI themes are already supported by Lively Kernel, however,
browser support for styling is not leveraged.

Another platform feature not used by Lively Kernel is
mouse event delivery. Instead of registering event handlers on
individual SVG elements, the <code>HandMorph</code> registers a single
input event handler in the capture phase of DOM event delivery. The
handler determines the morph that should receive the event based on
the coordinates contained in the event object and and geometry
information obtained by inspecting the morph tree. Clearly, Lively
Kernel duplicates in JavaScript some of the mechanisms implemented
natively by the DOM, however, event delivery turns out not to be
performance-critical, and the resulting codebase is more easily
portable to graphics backends not based on a DOM.
</para>



</section>






<section>
<title>SVG as a component of an application description format</title>



Even with multiple graphics backends,
the serialization format could be either an entirely new format (and n
translations for n platforms), or an existing format like SVG with n-1
translations for the remaining n-1 platforms.
<!-- copied from abstract --> 
It is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
<remark><para>drum up WebDAV as a persistence mechanism. Expound on
the possibility of a full-fledged SVG editor here</para></remark>

</section>

<section>
<title>Experiences with SVG implementations</title> 

<remark>
Firefox, Safari, Batik, Examotion/IE, Opera.  This area not
authoritative.

Better support highly
requested in the areas of drag and drop, copy and paste support,
filters for dropshadows. Font metric support either incorrect or not
available until webpage rendered).
<para>Correctness questions: we're not gurus but we ran into several problems
browser implementors (Apple) used to test correctness.
</para>
<para>Performance questions: we don't quite know, too early to make
meaningful measurements, efficiency of dynamic update to the SVG tree;
speed of bindings (height of the software layers between JS and the
graphics engine).
</para>

<para>Implementation alternatives: flex? silverlight? not open, no dynamicity</para>
<para>cooperation with other web technologies: foreignobject support,
leverage MIDAS html editing extensions? </para>

</remark>
</section>

<section>
<title>Future Work</title>
</section>

<bibliography>
  <title>References</title>
  
  <biblioentry xml:id="Taivalsaari08">
    <abbrev>Taivalsaari08</abbrev>
    <authorgroup>
      <author><personname> <firstname>Antero</firstname><surname>Taivalsaari</surname> </personname></author>
      <author><personname> <firstname>Tommi</firstname><surname>Mikkonen</surname> </personname></author>
      <author><personname> <firstname>Dan</firstname><surname>Ingalls</surname> </personname></author>
      <author><personname> <firstname>Krzysztof</firstname><surname>Palacz</surname> </personname></author>
    </authorgroup>
    <title>Web Browser as an Application Platform: The Lively Kernel Experience.</title>
  </biblioentry>

  <biblioentry xml:id="Maloney95">
    <abbrev>Maloney95</abbrev>
    Maloney, J. H. and Smith, R. B. 1995. Directness and liveness in
    the Morphic user interface construction environment. In
    Proceedings of the 8th Annual ACM Symposium on User interface and
    Software Technology (Pittsburgh, Pennsylvania, United States,
    November 15 - 17, 1995). UIST '95. ACM, New York, NY, 21-28.
    <link xlink:href="http://doi.acm.org/10.1145/215585.215636"/> 
  </biblioentry>

  <biblioentry xml:id="Batik">
    <abbrev>Batik</abbrev> 
    <title>The Batik SVG toolkit</title> 
    <link xlink:href="http://xmlgraphics.apache.org/batik/"/>
  </biblioentry>
  
</bibliography>


</article>
