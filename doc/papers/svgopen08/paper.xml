<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0b5/rng/docbook.rng" type="xml"?>
<?xml-stylesheet type="text/xsl" href="http://docbook.sourceforge.net/release/xsl/current/xhtml/docbook.xsl"?>

<!-- 
     Safari will load this file and honor the stylesheet spec above.
     Alternatively, a simple, slow, offline way of generating html from the command line:

     $ xsltproc http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl paper.xml > paper.html.

-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>The Lively Kernel Application Framework</title>
<!--    <subtitle></subtitle> -->
    <keywordset>
      <keyword>SVG</keyword>
      <keyword>GUI Frameworks</keyword>
      <keyword>Web Applications</keyword>
    </keywordset>
    <authorgroup>
    <author>
      <personname>
        <firstname>Krzysztof</firstname>
        <surname>Palacz</surname>
      </personname>
      <email>krzysztof.palacz@sun.com</email>
      <!-- <personblurb><para>Krzysztof Palacz is blah blah</para></personblurb>  -->
      <affiliation>
        <org>
          <orgname>Sun Microsystems Laboratories</orgname>
          <address>
            <city>Menlo Park</city>
            <street>16 Network Circle</street>
	    <postcode>94025</postcode> 
	    <state>CA</state>
	    <country>USA</country>
          </address>   
        </org>
      </affiliation>
      
    </author>
    <author>
      <personname> <firstname>Dan</firstname> <surname>Ingalls</surname> </personname>
      <email>dan.ingalls@sun.com</email>
      <affiliation>
        <org>
          <orgname>Sun Microsystems Laboratories</orgname>
          <address>
            <city>Menlo Park</city>
            <street>16 Network Circle</street>
	    <postcode>94025</postcode> 
	    <state>CA</state>
	    <country>USA</country>
          </address>   
        </org>
      </affiliation>
    </author>
    </authorgroup>

    <abstract>
      <para>
	
The Lively Kernel is a fully interactive, "zero-installation"
Web application framework and development environment written
entirely in JavaScript. The rich user experience of applications built
using the Lively Kernel is enabled by integrated programmatic access
to arbitrary 2D graphics, and owed in no small part to its
use of Scalable Vector Graphics and its bindings to the
JavaScript language.
</para>

<para>
Lively Kernel runs in SVG-enabled Web browsers without installation or
plug-in requirements; it offers a compact and extensible set of user
interface components. As a result, it supports familiar desktop-style
applications with the expected user interface functionality and direct
manipulation capabilities; it enables application development and
deployment in a Web browser with no installation or upgrades, using
only existing Web technologies. In addition to its application
execution capabilities, the Lively Kernel also functions as an
integrated development environment (IDE). Thus, it is
self-supporting and able to improve and extend itself
dynamically. Lively Kernel is currently also one of the most comprehensive
dynamic SVG frameworks available, and has become an important test
case for SVG implementations in Web browsers.
</para>

<para>
The main component of the Lively Kernel is a user interface framework
called Morphic, originally developed for the Self language, and later
incorporated into the Squeak Smalltalk system
(<xref linkend="Maloney95" />). The Morphic framework consists of
about 10,000 lines of uncompressed JavaScript code downloaded to the
Web browser on Lively Kernel startup. The central goal of Morphic is
to facilitate construction and editing of graphical objects, both
programmatically and by direct, interactive manipulation. Morphic
objects are editable, composable and animatable, Morphic also handles
user input and manages underlying system resources such as fonts,
gradients or images. Built-in mechanisms are provided for object
scaling, rotation, object editing, as well as for defining user
interface themes. Currently, visual editing tools are provided for
only a subset of the elements defined in the SVG specification,
however, our system could be easily extended to act as a complete SVG
authoring tool.
</para>

<para>
The Morphic framework also provides a library of higher level user
interface components, such as buttons, lists, menus, windows, etc.,
composed from the basic graphical objects, as well as a
Model-View-Controller infrastructure for abstracting visual
representation of data from application logic. The default
configuration of the Lively Kernel offers a familiar desktop metaphor
with multiple applications running concurrently, however, standalone
applications are also supported.
</para>

<para>
The Morphic framework includes tools for development, modification and
deployment of applications from within the Lively Kernel system
itself. The tools include a class browser, an object inspector and a
DOM inspector. The implementation of these tools relies on the
reflective capabilities of JavaScript, and can therefore be used
inside the Web browser without any external tools or IDEs. As a
result, it is possible to, e.g., create new JavaScript classes, modify
or delete existing methods, or change the value of any property in the
system. Finally, it is possible to export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment for both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of the asynchronous HTTP networking support
present in all modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
</para>
</abstract>
</info>
<section>

<title>The Lively Kernel approach to Rich Internet Applications</title>



<para>
The explosive growth of the Internet and growing interest in expanding
interactive functionality and usability of Web applications has
recently sparked a revival of sorts of graphical user interface (GUI)
framework development. The cross-platform, standards-oriented nature
of enabling technologies available in commercial Web browsers lowered
the barrier of entry to the field of GUI framework development, and
greatly reduced the dependence on operating system vendors and their
software distribution and update channels. As a result, a variety of
popular, actively developed Web-based GUI frameworks have sprung up,
usually as main components of so called <emphasis>AJAX</emphasis>
toolkits, which leverage the JavaScript language, dynamically updated
Hypertext Markup Language (HTML) content and asynchronous requests for
data in expressed in the Extensible Markup Language (XML) to provide
rich user experience. Dojo (<xref linkend="Dojo"/>, ExtJS
(<xref linkend="ExtJS"/>) and
Scriptaculous <xref linkend="Scriptaculous"/>) are excellent examples
of such frameworks. On the other hand, vendors such as Adobe and
Microsoft, recognize the limitations of technologies implemented by
Web browsers, and promote proprietary frameworks based on external
runtimes available as browser plug-ins, such as Adobe Flash, Adobe
Flex and Microsoft Silverlight.
</para>


<para>
Naturally, currently available AJAX toolkits aim to reproduce the
functionality and usability of a modern desktop GUI framework. This
paper presents an alternative approach, a system that capitalizes on
decades of GUI research and innovation outside the mainstream practice
of GUI framework design. The renewed interest in GUI frameworks
presents itself as a unique opportunity to advance the state of art
and offer these results to wider audiences.  The system's main
intended improvement is a much higher level of dynamicity and
malleability, offered equally to the programmer and to the interactive
user. The system is called Lively Kernel, to emphasize both the intent
to apply the notions of read-write Web to graphics programming, and
focus on compactness, self-containment and comprehensibility to a
single programmer.
</para>

<!--
<remark>
<para>
LK aims to improve both functionality and developer-visible software
architecture.
</para>
</remark>
-->

<para>
Lively Kernel follows typical AJAX toolkits by using JavaScript as its
implementation language. This choice is pragmatic, as JavaScript is
the only programming language uniformly implemented in modern Web
browsers, but it is also conductive to project goals, because the
language is reasonably dynamic. However, Lively Kernel strays form the
commonly followed path of using HTML. While existing AJAX toolkits
achieve wonders by building on top of what was intended to be a text
publishing format, the Scalable Vector Graphics (SVG,
<xref linkend="SVG11"/>) standard addresses the shortcomings of HTML
and is a much better foundation for interactive graphical applications
on the Web.
</para>

<para>
This paper presents the SVG backend of the Lively Kernel. We have
found the SVG standard to be a rich and expressive graphics substrate, and its
implementations in widely available Web browsers demonstrate well the
potential of our approach. While our current work is almost
exclusively built on top of the SVG backend, we are equally interested
in portability to other graphics substrates.  In fact, an earlier
version of our system provided a custom browser-like environment on
top of the Java platform, using the Java2D APIs as its graphics subsystem
and Rhino as its JavaScript execution engine.
</para>



<para>
Despite being based on a text markup format, Lively Kernel presents a
traditional procedural application programmer's interface (API), which
acts as a layer of abstraction over SVG and other graphics
backends. The SVG backend itself does not rely on text markup and
accesses the SVG implementation through its Document Object Model
(DOM) interface.  The resulting system is both compact (approximately
10,000 lines of code, including comments) and expressive. For
instance, Lively Kernel is more than capable of implementing
traditional desktop metaphors, as shown in
<xref linkend="fig_desktop"/>. The system's code base is uniformly
implemented in JavaScript, and relieves the programmer from the mental
context switching required when inspecting and developing in a system
implemented using multiple technologies and formats, as is typically
the case in existing AJAX toolkits based on HTML, CSS, JavaScript and
auxiliary technologies.
</para>


<figure xml:id="fig_desktop">
<title>Lively Kernel desktop</title>
<mediaobject><imageobject>
<imagedata fileref="screenshot.png"/>
</imageobject></mediaobject>
<caption><para>Example instantiation of the Lively Kernel.</para></caption>
</figure>

</section>

<section>
<title>Morphic User Interface Framework</title>

<para>
The majority of the JavaScript classes defined by the Lively Kernel
are related to a user interface framework called Morphic
(<xref linkend="Maloney95" />).  The Morphic framework was developed
originally for the Self language and system (<xref linkend="Self" />),
and later became popular as the user interface of the Squeak Smalltalk
system (<xref linkend="Squeak"/>). Lively Kernel reimplements a sizable
subset of the Morphic framework using technologies available in modern
Web browsers.
</para>

<para>
Morphic achieves simplicity of programmatic and interactive access by
consistently relying on a class of graphical objects called “morphs”,
possessing some or all of the following properties:
<itemizedlist mark="bullet">
  <listitem> <para>
      A shape, or graphical appearance,
  </para> </listitem>
  <listitem> <para>
      A set of submorphs, comprising the “scene graph” of the page or world,
  </para> </listitem>
  <listitem> <para>
      A coordinate transformation that affects its shape and any submorphs,
  </para> </listitem>
  <listitem> <para>
      An event handler for mouse and keyboard events,
  </para> </listitem>
  <listitem> <para>
      An editor for changing its shape,
  </para> </listitem>
  <listitem> <para>
      A layout manager for laying out its submorphs,
  </para> </listitem>
  <listitem> <para>
      A stepping protocol for time-varying behavior,
  </para> </listitem>
  <listitem> <para> A damage rectangle repainting protocol and
      double-buffered display mechanism (used when the underlying
      graphics substrate does not provide it).
  </para> </listitem>
</itemizedlist>
</para>

<para>
Morphic defines several classes of morphs with special semantics.
A <code>WorldMorph</code> captures the notion of an entire web page;
its shape defines its background appearance, if any, and its submorphs
comprise all the remaining content of the page. In contrast to typical
web pages, however, multiple worlds can coexist in a single JavaScript
execution context. Notionally, the user interacts with the contents of
single world, and navigates between different worlds by clicking on
<code>LinkMorphs</code>, representing connections between worlds.
</para>

<para>
A <code>HandMorph</code> is the Morphic generalization of a cursor; it
can be used to pick up, move, and deposit other morphs, its shape may
change to indicate different cursor states, and it is the source of
user events in the architecture.  In Lively Kernel, a Morphic world
may have several hands active at the same time, corresponding to
several collaborating users of that world (this functionality is not
yet available in the current incarnation of the Lively Kernel,
although, it has been demonstrated in the previously mentioned
prototype based on the Java platform).
</para>
<para>
In many respects Lively Kernel can be viewed as an interactive editing
environment for graphic and non-graphic information. The remainder of
this section presents various aspects of the Morphic framework in
terms of its editing capabilities.
</para>

<section>

<title>A Lively Construction</title>
<para>
Morphic supports interactive manipulation of morphs included
in the framework, and, by extension, composite morphs assembled from
the morphs already in existence.  In contrast with the mostly static
elements of typical Web pages, each morph in a Lively Kernel world can
be picked up, moved, resized, rotated, duplicated and reshaped. 

</para>

<para>

The sequence shown in <xref linkend="fig_construction"/> illustrates
the construction of a simple truck shape by concrete manipulation. In
Figure A we see a palette of useful shapes.  In Figure B, the
rectangle has been copied, and extended in Figure C.  In Figure D, the
rectangle has been colored yellow, an ellipse has been copied,
resized, and colored, and has been given a thick black border to
resemble a tire, and a second copy has already been affixed to the
bus.  In Figure E, the truck is complete, and Figure F shows a family
of trucks, copied and rotated from the new master, all operations that
can be accomplished with simple gestures in the Lively Kernel's
graphics editor.
</para>


<figure xml:id="fig_construction">
<title>Construction through visual manipulation</title>
<para>

<mediaobject>
<imageobject><imagedata fileref="construction-a.png"/> </imageobject>
<textobject><phrase>a</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject><imagedata fileref="construction-b.png"/></imageobject>
<textobject><phrase>b</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-c.png"/></imageobject>
<textobject><phrase>c</phrase></textobject>
</mediaobject>
</para>
<para>

<mediaobject>
<imageobject> <imagedata fileref="construction-d.png"/></imageobject>
<textobject><phrase>d</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-e.png"/></imageobject>
<textobject><phrase>e</phrase></textobject>
</mediaobject>

<mediaobject>
<imageobject> <imagedata fileref="construction-f.png"/></imageobject>
<textobject><phrase>f</phrase></textobject>
</mediaobject>
<caption>Drag and drop construction of simple objects in Lively Kernel.</caption>
</para>

</figure>


<!--Extending the graphical vocabulary  -->
<para>
<figure xml:id="fig_spiral">
<title>Extending the graphical vocabulary</title>
<mediaobject><imageobject>
<imagedata fileref="spiral.png"/>
</imageobject></mediaobject>
<caption><para>The red spiral on the left hand side is a morph created
programmatically by the code contained in the rectangle on the
right. The orange spiral in the center is derived from it by
interactive manipulation.</para></caption>
</figure>
</para>
<para>
Beyond the basic vocabulary of the underlying graphics support, the
programmability of Morphic shapes provides an unlimited range of
graphical idioms. <xref linkend="fig_spiral"/> shows a small
snippet of JavaScript that draws a polygonal spiral.   
The code demonstrated in the figure produces not merely marks on the
screen, but, rather, a fully active object that can be copied, scaled,
and colored, as shown, and that could be set to spinning with one more
line of code, such as
<programlisting><![CDATA[
this.startStepping(50, “rotateBy”, 0.1); // 0.1 radians every 50 ms
]]></programlisting>
</para>


</section>
<section><title>Simple Editors</title>

<figure xml:id="fig_editors">
<title>Simple editors.</title>
<mediaobject><imageobject>
<imagedata fileref="editors.gif"/>
</imageobject></mediaobject>
<caption>A SelectionMorph (left) and a HandleMorph (the blue rectangle on the polygon; shown with balloon help). <remark>FIXME better pic: tray, handle and color picker</remark> </caption>
</figure>




<para>
Beyond mouse gestures and keyboard shortcuts, Morphic provides simple
user interface elements to edit the visual appearance of morphs.
Morph editors are morphs themselves, in particular, shape editors are
instances of <code>HandleMorph</code> and expose user interface
bindings for resizing, rotating, reshaping and rotating the target
morph. Morphic also provides other editor morphs, among
them <code>ColorPickerMorph</code>, used to select and apply solid
colors to <code>fill</code> and <code>stroke</code> attributes,
and <code>SelectionMorph</code> (or “selection tray”), which allows
the same operations to be applied to multiple morphs (see
<xref linkend="fig_editors"/>).  Further morph editing operations are
available through contextual menus, also implemented as morphs.
</para>


</section>


<section><title>Editing text</title>
<para>
An editable graphics environment would not be complete without support
for editing text, and Lively Kernel comes with a rich text editor
built into every <code>TextMorph</code>, the basic text container and
unit of text manipulation.  The Lively Kernel provides this
functionality with three basic components:

<itemizedlist mark="bullet">
  <listitem> <para> A rich text model (<code>Text, RunArray, TextEmphasis</code>)</para>
    <para> TextEmphasis is an aggregate property, such
      as <code>{style: 'bold', fontSize: 14}</code>, together with a
      method for merging with other instances.  <code>RunArray</code> is a
      compactly encoded array of <code>TextEmphasis</code> objects corresponding to
      every character of a Text.  Most of the work is associated with
      slicing and concatenating these objects.  An optimization allows
      efficient streaming through what is effectively a sparse
      structure.  Text is nothing more than a String of characters
      with a matching RunArray of emphasis.
    </para>
  </listitem>
  <listitem> 
    <para> A text composition facility (<code>Font, TextWord, TextLine, TextMorph</code>)</para>
    <para> Text composition is merely a process of streaming through
      the text, noting exceptions when emphasis changes, and when the
      frame boundary or mouse location is
      encountered.  <code>TextLine</code> and <code>TextWord</code>
      capture the state of this process, and allow efficient display
      and location of the individual characters.
    </para>
  </listitem>
  <listitem> <para> A text editor (<code>TextMorph, TextSelection</code>) </para>
    <para> 
      Once text has been composed, a text editor
      dispatches user events to manipulate the current selection and alter
      either the content or the emphasis of the selected text.
    </para>
  </listitem>
</itemizedlist>
</para>

<para>The totality of the text package in the Lively Kernel is
approximately 2000 lines of JavaScript, including comments.  Lists and
menus are built from it in a further 400 lines.
<remark> not sure of either -- I think 2000 may be without the editor,
and 400 for lists and menus was a guess</remark>
</para>

<para> 
The decision to tackle active text was a daunting one.
Composition of text is the most complex module in the Lively Kernel.
Access to font metrics is complex and browser-dependent, and
character-by-character composition is a challenge even for the faster
JavaScript implementations.  That said, we consider the achievement of
active WYSIWYG text, independent of native widgets, to be a
breakthrough.  In a context such as SVG, arbitrary text and graphics
can now be freely mixed, interactive changes can be made through
arbitrary coordinate transformations, all without concern for
installation barriers or browser-specific text problems.
</para>

<para>
It should be noted here that many modern browsers, such as those
derived from the Gecko rendering engine employed in the Firefox
browser, contain a built-in rich text editor. One could argue that the
resulting duplication of editing functionality in JavaScript is
undesirable, however, the rich text editors are neither standardized
nor easily integratable with SVG. The SVG specification allows
integration of XHTML content through
the <code>&lt;foreignobject&gt;</code> element, which can be
manipulated, most notably using affine transforms, much like other SVG
elements. However, the Gecko engine currently only supports editing
HTML content, and not XHTML, and as of this writing, other browsers
exhibit similar limitations.  Even if XHTML editing were supported by
all browsers, performing text editing in Lively Kernel results in more
self contained code, and as a result, retains its character as a
computing kernel.
</para>

</section>

<section><title>Editing abstract data: widgets and Model-View-Controller (MVC) architecture</title>

<figure xml:id="fig_widget">
<title>An example MVC widget</title>
<mediaobject><imageobject>
<imagedata fileref="mvc-widget.png"/>
</imageobject></mediaobject>
<caption>A composite widget comprising multiple Views on parts of the same Model.</caption>
</figure>



<para>
The editing capabilities presented so far are related to editing SVG
graphics, but Lively Kernel is capable of editing other kinds of
structured data In particular, the Lively Kernel's widget set has been
implemented with a Model-View separation along the lines of many
Smalltalk systems, and, in this context, views forming a Lively Kernel
widget can be regarded as editors for parts of a shared model. This
architectural choice was influenced by experience with GUI-builder
applications and the Fabrik visual programming system
<xref linkend="Ingalls88" />.  Besides allowing for multiple views of
a given model, the Model-View separation makes it easier to infer
appropriate model structure from a given concrete assembly of UI
components.  It also turns out to provide a flexibility that is vital
for migration of functionality between client and server where this is
desired.
</para>


<para>
<xref linkend="fig_widget"/> shows a number of simple widgets
arranged in a test panel.  It is not much to look at as a picture, but
if one runs the Lively Kernel from our site, one finds that the
buttons, text boxes and lists are in groups that exhibit bidirectional
coupling through their shared models.  For instance the slider is
hooked to a numerical model that is bidirectionally connected to one
of the text views with a read/print converter.
</para>

<para>
We made the claim above that even a rudimentary assembly of widgets is
the makings of open-ended computing.  This should not surprise any of
our readers, and we see in  <xref linkend="fig_browser"/> a
piece of almost professional-looking software which is little more
than an assembly of text boxes, lists, a clipping component, and the
same slider shown in <xref linkend="fig_widget"/>, now doing
service in (almost) vertical orientation as a scroll bar.
</para>


<figure xml:id="fig_style_editor">
<title>Built-in style editor</title>
<mediaobject><imageobject>
<imagedata fileref="stylepanel.gif"/>
</imageobject></mediaobject>
<caption>FIXME better pic needed</caption>
</figure>


<para> The Model-View separation can be applied to SVG data itself, as
shown in <xref linkend="fig_style_editor"/>, demonstrating a simple style editor widget. A
style editor can be invoked for every morph, and it can be considered
a view observing parts of the SVG DOM as its model.
</para>

<!--
<remark>
<para> browser for tree-structured data. Figure with a DOM browser
side by side with a file browser and object browser. Applicable to SVG
DOM but any other kind of structured data (experimental).

Also, potentially, tree-structured Models. Mention potential
relationship to XForms?
</para>

</remark>
-->

</section>

<section><title>Editing source code: development tools</title>
<para>
<figure xml:id="fig_browser">
<title>Class browser in action</title>
<mediaobject><imageobject>
<imagedata fileref="browser.png"/>
</imageobject></mediaobject>
<caption><para>Code browser editing executable code for a clock
widget. </para></caption>
</figure>
</para>

<para>
While visual editors are currently suffcient to control many aspects
of visual appearance, other tools are necessary to modify the behavior
of widgets and applications. Lively Kernel does currently not provide
a full visual programming environment (although such an environment
certainly lies within the interests of the project), but it does
provide tools to directly edit the JavaScript code of running
applications. <xref linkend="fig_browser"/> presents a class
browser inspecting an example clock widget. The class browser itself
is obviously a fully functional widget, and, as shown, functions the
same with arbitrary affine transformations applied to it. Saving
edited code results in instantaneous updates to the clock's behavior.
For instance, inserting a minus sign in the argument to the last call
in the body of the method shown will cause the clock to start running
backwards. 
</para>

<para>
The code of function bodies presented to the programmer within the
Lively Kernel can be simply obtained from many JavaScript
implementations (using the <code>toString()</code>
or <code>toSource()</code> methods of the <code>Function</code>
object).  However, such code is a result of decompilation, and does
not include comments or custom formatting. Moreover, while new
functions can be introduced and bound to existing object member names
dynamically, such changes do not persist past the lifetime of the
Lively Kernel instantiation.
</para>
<para>
Code persistence is implemented by a source code database, a component
of the Lively Kernel. Currently the programmer can request
interactively that function bodies be associated with the locations of
their definitions in the source files used to instantiate the
executing runtime. A fast scanner retrieves all the source files into
the browser, locates all the method definitions and matches them with
runtime function objects. When changes are made to a method
definition, the source file containing the method is regenerated in
the browser with the updated definition, and saved back to the server,
subject to access control checks. Server-side code persistence is
implemented using Lively Kernel's own implementation of the WebDAV
protocol (<xref linkend="WebDAV" />, see <xref linkend="Serialization"/> for more details). 


<!-- An active implementation of the
WebDAV protocol server is required on the Web server hosting the
Lively Kernel installation.
-->
</para>

</section>
</section>

<section><title>Implementing Morphic in SVG</title>


<para>
Thanks in no small part to the expressiveness and dynamicity of
JavaScript and SVG, the Lively Kernel code base is compact, yet it
provides an entire toolchain for graphics and application development
and deployment, as well as for evolution of the system
itself. <xref linkend="fig_breakdown"/> demonstrates the lines of code
used to implements various subsystems in a snapshot of Lively Kernel
code base. Among those subsystems, <code>Basic
Graphics</code>, <code>Shape</code>, <code>Morphic Core</code>
<code>Text</code> and <code>Editors</code> directly depend on SVG. The
remainder of this section concentrates on the dilemmas and solutions
encountered while implementing the Lively Kernel SVG backend.
</para>

<para>
Lively Kernel takes a highly dynamic approach to interfacing with the
SVG implementation. First of all, the entire SVG DOM tree is built
dynamically on system load. The default entry point to the Lively
Kernel runtime is a very simple static document defining only a single
empty <code>&lt;svg&gt;</code> element, and all the SVG elements
subsequently created by the system are its descendants.  This element
act as a canvas, on which the current <code>WorldMorph</code> displays
itself. When a new world is entered, all the SVG elements used to
represent it are (directly or indirectly) inserted into the DOM tree,
and the old world's SVG elements are removed from it.
</para>


<para>
Lively Kernel uses an SVG <code>&lt;g&gt;</code> element to implement
the <code>HandMorph</code>. As a result, the mouse cursor drawn by the
windowing system is closely followed within the confines of the SVG
canvas by a visual representation of the <code>HandMorph</code>,
typically a small arrow shape. Such a choice may appear surprising,
but it reflects the fact that multiple <code>HandMorphs</code> may
interact with the same <code>WorldMorph</code>, and enables uniform
handling of morphs residing in a world and morphs held by
a <code>HandMorph</code> (in Morphic, morphs grabbed by
a <code>HandMorph</code> are taken out of the world of residence). SVG
supports changing and disabling the windowing system cursor
entirely, and Lively Kernel provides programmatic bindings for this functionality.
</para>

<!-- Imperative API for SVG, hiding the XML underpinnings and hence
portable to different architectures. API JS-centric (hence no XBL,
even though similar interest in reusable components).
-->

<table xml:id="fig_breakdown" frame='all'>
<title>Breakdown of the implementation code</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<colspec colname='total'/>
<colspec colname='name'/>
<colspec colname='desc'/>
<thead>
<row>
  <entry>Total</entry>
  <entry>Name</entry>
  <entry>Description</entry>
</row>
</thead>
<tfoot>
<row>
  <entry>12954</entry>
  <entry>Total</entry>
  <entry></entry>
</row>
</tfoot>
<tbody>
<row><entry>319</entry><entry>Host Interface</entry><entry>Browser API plus XML utility functions</entry></row>
<row><entry>515</entry><entry>Utility</entry><entry>Classes, collections, printing, etc. (plus 562 in Prototype.js)</entry></row>
<row><entry>833</entry><entry>Basic Graphics</entry><entry>Point, Rectangle, Transform, Color, Gradient, Image</entry></row>
<row><entry>550</entry><entry>Shapes</entry><entry>Host graphical objects (SVG node API)</entry></row>
<row><entry>1667</entry><entry>Morph</entry><entry>Basic protocol</entry></row>
<row><entry>1170</entry><entry>Morphic Core</entry><entry>World, Hand, Event, Handles, Handlers</entry></row>
<row><entry>1188</entry><entry>Basic Widgets</entry><entry>Button, List, Menu, Dialog, Slider, Selection, ImageMorph </entry></row>
<row><entry>1921</entry><entry>Text</entry><entry>basic TextMorph plus composition and rich text </entry></row>
<row><entry>747</entry><entry> Editors</entry><entry>Drag/drop manipulation, shape editors and text editing also ColorPicker and StylePanel </entry></row>
<row><entry>386</entry><entry>Model, Widget</entry><entry>Model-View-Controller implementation</entry></row>
<row><entry>1295</entry><entry>High Level Widgets</entry><entry>Scroll panes, panels, windows, world links, also Panel and Browser support </entry></row>
<row><entry>1311</entry><entry>Tools</entry><entry>Browser, inspector, stack viewer, change lists, profiler </entry></row>
<row><entry>406</entry><entry>Serialization</entry><entry>Copier, exporter, importer (plus 202 in JSON) </entry></row>
<row><entry>281</entry><entry>Network</entry><entry>URL, HTTP, WebDAV basics </entry></row>
<row><entry>365</entry><entry>Storage</entry><entry>WebDAV, file browser </entry></row>

</tbody>
</tgroup>
<caption><para> Breakdown of the Lively Kernel by function with
    approximate code size. Numbers include comments and lines
    with single bracket characters.  Prototype.js is an open source
    set of useful JavaScript extensions, of which we use only a small
    number (see <link xlink:href="http://www.prototypejs.org"/>), JSON is Doug Crockford's
    implementation the parser for the JSON data interchange format (see
    <link xlink:href="http://www.JSON.org"/>).
</para></caption>
</table>            





<section>
<title>Containment</title>
<para>The Morphic framework organizes visual objects on the screen
using a tree of morphs. Each morph has a single owner morph and can
act as a container for other morphs. The SVG backend of Lively Kernel
naturally maps morphs onto SVG <code>&lt;g&gt;</code> elements. The
semantics of <code>&lt;g&gt;</code> elements corresponds well to the
semantics of Morphic, specifically, the nesting of
<code>&lt;g&gt;</code> elements is a means of logical organization and
does not imply visual containment, and submorphs are not necessarily
visually contained inside their owner morphs, either. A morph's shape is
represented by one of the basic SVG shape elements, such
as <code>&lt;rect&gt;</code>, <code>&lt;ellipse&gt;</code>,
or <code>&lt;path&gt;</code>.
</para>

<para>
Currently, Lively Kernel does not take advantage of the property
inheritance mechanism of <code>&lt;g&gt;</code> elements provided by
the SVG specification, and each basic shape element is required to specify the
full set of its visual attributes. This feature of the SVG standard
could be potentially taken advantage of, both as implementation
technique to improve space utilization, and as an API-level
programming abstraction (perhaps as a mechanism to specify widget
"skins").
</para>
</section>


<para>
The Lively Kernel SVG backend allocates a private
 <code>&lt;defs&gt;</code> element to every morph. The SVG
specification designates <code>&lt;defs&gt;</code> elements as
containers for elements that are not directly rendered on the screen,
such as gradients or clip paths. These elements are typically referred
to by URI attributes on other elements (the SVG standard makes
extensive use of URI references to express relations between elements
that are not captured by the DOM tree hierarchy). This design
facilitates space optimizations through sharing of commonly used
elements, however, Lively Kernel does not currently take advantage of
it. Instead, all the elements in a morph's <code>&lt;defs&gt;</code>
section are notionally owned by the morph, and the URIs of these
elements are trivially derived from the URI of the
morph's <code>&lt;g&gt;</code> element. As a result, every morph
defines all the gradients it uses, even though a typical user
interface uses only a handful of distinct gradient definitions that
could be shared and applied to multiple visual elements. This may be
perceived as a shortcoming of the current SVG backend, however, the
presented technique does simplify certain implementation aspects, most
notably copying and serialization of individual morphs. We envision
that a future version of our system could implement gradient sharing,
most likely through a uniform reference counting facility for all SVG
elements referenced through URIs.
</para>

<!--What does it have to do with Lessphic? -->

<section> 
<title>The implementation of mapping: wrapping versus extending DOM elements</title>
<para>
There are at least two general methods of implementing the mapping
of abstract tree data structures, such as the morph tree defined by
the Morphic API, to DOM trees. The first involves extending
appropriate DOM elements so that they <emphasis>become</emphasis>
morphs. This was the method originally used by the Lively Kernel SVG
backend. Despite its conceptual simplicity, it required certain
non-obvious implementation techniques. For instance, while all morphs
were mapped to <code>&lt;g&gt;</code> elements, the converse was not
deemed appropriate: not all <code>&lt;g&gt;</code> elements should be
morphs. In order to satisfy this requirement, morph factory methods
dynamically modified the inheritance chain of <code>&lt;g&gt;</code>
elements intended to become morphs, by inserting a morph prototype
object, defining the functionality shared by all morphs. Such
modifications are not possible according to the ECMAScript language
specification (an object's <code>prototype</code> is generally not
accessible programmatically), however, most JavaScript implementations
recognize this problem as a language limitation, and make the object
prototype accessible through a mutable <code>__proto__</code> property
that can be manipulated to obtain the desired inheritance
behavior. Unfortunately, this approach eliminated the Opera browser
from the list of potential Lively Kernel platforms, since its
JavaScript engine does not implement <code>__proto__</code>.
</para>

<para>
A minor inconvenience of this approach was that new morphs were
instantiated using factory methods of the form <code>MyMorph()</code>,
instead of explicit allocation syntax, as in <code>new
MyMorph()</code> (as a side note, due to the semantics of JavaScript,
accidental insertion of the <code>new</code> keyword did not affect
the correctness of the program, but merely resulted in a wasteful
allocation of an unused object). A much more important limitation
turned out to be the incompatibility with environments such as Batik
(<xref linkend="Batik" />), which support the <code>__proto__</code> property but
do not allow extension of host objects (i.e., objects created and
managed outside of the JavaScript runtime, such as DOM objects, and
merely exposed programmatically to JavaScript).
</para>

<para>
In the face of the limitations, the subsequent reimplementation of the
Lively Kernel SVG backend uses a more conventional implementation
technique based on <emphasis>wrappers</emphasis>. Morphs are
implemented as regular, user-defined JavaScript objects furnished with
a <code>rawNode</code> property, pointing to the host object
representing the corresponding <code>&lt;g&gt;</code>
element. Similarly, <code>Shape</code> objects wrap simple SVG shape
elements referred to through their <code>rawNode</code> property. No
new properties or methods are added to host objects, and many Morph
and Shape methods simply delegate to the
underlying <code>rawNode</code>. Unfortunately, the object identity of
the Morph is now distinct from the identity of the
underlying <code>rawNode</code>, which requires additional boilerplate
code to map from Morphs to DOM objects. Interestingly, other than
while debugging, it is currently never necessary to find a
corresponding Morph given the DOM element that implements it, is due
largely to the fact that Lively Kernel performs its own mouse event
delivery.

The technique itself is of course well known, in particular the Dojo
toolkit <xref linkend="Dojo"/> uses a similar approach for its cross-platform graphics
library <code>dojo.gfx</code>, and Lively Kernel even borrows its
convention of naming the underlying DOM element <code>rawNode</code>.
</para>

</section> <!-- end of wrapping vs extending -->


<para>
Lively Kernel does not currently use several features of the SVG
specification. Most notably, it does not use declarative animations,
botu due to lack of support in many browsers, and to our interest in
portability of the implementation to other graphics backends. Instead,
a simple imperative framework for scheduling and periodic invocation
of user-supplied actions is provided. Document styling (through either
Cascading Style Sheets or Extensible Stylesheet Language standards) is
not currently used, either, although useful applications of styling
could be envisioned. For instance, styling could be used to implement
UI themes, i.e., sets of visually coherent presentation attributes
that can be applied to a widget or application at the user's
discretion. UI themes are already supported by Lively Kernel, however,
browser support for styling is not leveraged.

Another platform feature not used by Lively Kernel is mouse event
delivery. Instead of registering event handlers on individual SVG
elements, the <code>HandMorph</code> registers a single input event
handler in the capture phase of DOM event delivery. The handler
determines the morph that should receive the event based on the
coordinates contained in the event object and and geometry information
obtained by inspecting the morph tree. Clearly, Lively Kernel
duplicates in JavaScript some of the mechanisms implemented natively
by the DOM, however, event delivery is not usually
performance-critical, and the resulting codebase is more easily
portable to graphics backends not based on a DOM.
</para>



</section>

<section xml:id="Serialization">
<title>SVG as a serialization and application description format</title>


<para>
No autoring environment would be complete without saving the results
into a persistent form, and Lively Kernel addresses this requirement
by providing a simple WebDAV protocol client implemented in
JavaScript. The client is built on top of asynchronous HTTP networking
support present in all the modern browsers in form of
the <code>XmlHttpRequest</code> object. Rather than using one of the
several JavaScript frameworks, Lively Kernel provides its
own <code>XmlHttpRequest</code> wrapper, which leverages the
asynchronous model update notification mechanism used in other parts
of the system. Naturally, the WebDAV protocol has to be implemented
and enabled on the Web server hosting the Lively Kernel
installation. Due to the single origin security policy implemented by
web browsers (and in absence of server side proxies), the WebDAV
client can only save files to the website from which the current
runtime has been loaded.
</para>

<para>
Lively Kernel is able to save not only static JavaScript files and SVG
documents, it can also save snapshots of its own active worlds. Such
snapshots can be later loaded into a running runtime and their
contents manipulated as any other Lively Kernel object.  Moreover, the
snapshot files are active Web pages themselves, and, when loaded by a
supported Web browser, instantiate a new Lively Kernel runtime and
recreate the worlds contained therein. When the JavaScript runtime is
not available (because JavaScript execution is disabled or the
required JavaScript files cannot be found), the snapshot Web page is
simply rendered as a static screenshots of the active world at the time the
save operation was performed.
</para>

<para>
<remark>
 The chanllenges are the format and how to implement
writing out the format from within a web browser.  Even with multiple
graphics backends, the serialization format could be either an
entirely new format (and <code>n</code> translations
for <code>n</code> platforms), or an existing format like SVG
with <code>n-1</code> translations for the remaining <code>n-1</code>
platforms.
</remark>
</para>
<!-- copied from abstract --> 
<para>
It is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
</para>
<!--
<remark><para>drum up WebDAV as a persistence mechanism. Expound on
the possibility of a full-fledged SVG editor here</para></remark>
-->


</section>

<section>
<title>Experiences with SVG implementations</title> 

<remark>
Firefox, Safari, Batik, Examotion/IE, Opera.  This area not
authoritative.

Better support highly
requested in the areas of drag and drop, copy and paste support,
filters for dropshadows. Font metric support either incorrect or not
available until webpage rendered).

<para>Correctness questions: we ran into several problems
browser implementors (Apple) used to test correctness.
</para>

<para>Performance questions: too early to make entirely meaningful
measurements, questions of efficiency of dynamic update to the SVG
tree; speed of bindings (height of the software layers between JS and
the graphics engine).
</para>

<para>Implementation alternatives: flex? silverlight? not open, no dynamicity</para>
<para>cooperation with other web technologies: foreignobject support,
leverage MIDAS html editing extensions? </para>

</remark>
</section>

<section>
<title>Conclusion</title>
<para>

Our Morphic implementation does not currently provide editors for all
the elements and attributes specified by the SVG standard, however,
such a complete implementation would certainly be feasible, and would
constitute an interesting light-weight, self-sustaining graphics
editor for the Web. <remark> possible but not strictly  research goal, perhaps the community will pick up.</remark>

</para>

</section>

<bibliography>
  <title>References</title>
  <biblioentry xml:id="Ingalls88">
    <abbrev>Ingalls88</abbrev>
    <title>Fabrik.  A Visual Programming Environment</title>
    Dan Ingalls, Scott Wallace, Yu-Ying Chow, Frank Ludolph, Ken Doyle 
    Apple Computer Inc. 
    OOPSLA '88 Conference Proceedings 
    SIGPLAN Notices 
    Volume 23, Number 11, November 1988 
  </biblioentry>
    
  <biblioentry xml:id="Taivalsaari08">
    <abbrev>Taivalsaari08</abbrev>
    <authorgroup>
      <author><personname> <firstname>Antero</firstname><surname>Taivalsaari</surname> </personname></author>
      <author><personname> <firstname>Tommi</firstname><surname>Mikkonen</surname> </personname></author>
      <author><personname> <firstname>Dan</firstname><surname>Ingalls</surname> </personname></author>
      <author><personname> <firstname>Krzysztof</firstname><surname>Palacz</surname> </personname></author>
    </authorgroup>
    <title>Web Browser as an Application Platform: The Lively Kernel Experience.</title>
  </biblioentry>

  <biblioentry xml:id="Maloney95">
    <abbrev>Maloney95</abbrev>
    Maloney, J. H. and Smith, R. B. 1995. 
    <title>Directness and liveness in the Morphic user interface construction environment.</title>
      In Proceedings of the 8th Annual ACM Symposium on User interface and
    Software Technology (Pittsburgh, Pennsylvania, United States,
    November 15 - 17, 1995). UIST '95. ACM, New York, NY, 21-28.
    <link xlink:href="http://doi.acm.org/10.1145/215585.215636"/> 
  </biblioentry>

  <biblioentry xml:id="Batik">
    <abbrev>Batik</abbrev> 
    <title>The Apache Batik SVG toolkit</title> 
    <link xlink:href="http://xmlgraphics.apache.org/batik/"/>
  </biblioentry>

  <biblioentry xml:id="SVG11">
    <abbrev>SVG11</abbrev> 
    <title>Scalable Vector Graphics (SVG) Specification</title> 
    <link xlink:href="http://www.w3.org/TR/SVG11/"/>
  </biblioentry>

  <biblioentry xml:id="Dojo">
    <abbrev>Dojo</abbrev> 
    <title>The Dojo Toolkit</title> 
    <link xlink:href="http://www.dojotoolkit.org/"/>
  </biblioentry>

  <biblioentry xml:id="ExtJS">
    <abbrev>ExtJS</abbrev> 
    <title>The ExtJS JavaScript library</title> 
    <link xlink:href="http://extjs.com/"/>
  </biblioentry>

  <biblioentry xml:id="Scriptaculous">
    <abbrev>Scriptaculous</abbrev> 
    <title>The Scriptaculous user interface library.</title> 
    <link xlink:href="http://script.aculo.us/"/>
  </biblioentry>

  <biblioentry xml:id="Self">
    <abbrev>Self</abbrev> 
    <title>The Self Language</title> 
    <link xlink:href="http://research.sun.com/self/"/>
  </biblioentry>

  <biblioentry xml:id="Squeak">
    <abbrev>Squeak</abbrev> 
    <title>The Squeak Smalltalk system</title> 
    <link xlink:href="http://www.squeak.org"/>  
  </biblioentry>

  <biblioentry xml:id="WebDAV">
    <abbrev>WebDAV</abbrev> 
    <title>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</title> 
    <link xlink:href="http://www.ietf.org/rfc/rfc4918.txt"/>  
  </biblioentry>

</bibliography>


</article>
