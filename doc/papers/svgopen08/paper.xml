<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0b5/rng/docbook.rng" type="xml"?>
<?xml-stylesheet type="text/xsl" href="http://docbook.sourceforge.net/release/xsl/current/xhtml/docbook.xsl"?>

<!-- 
     Safari will load this file and honor the stylesheet spec above.
     Alternatively, a simple, slow, offline way of generating html from the command line:

     $ xsltproc http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl paper.xml > paper.html.

-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>The Lively Kernel Application Framework</title>
<!--    <subtitle></subtitle> -->
    <keywordset>
      <keyword>SVG</keyword>
      <keyword>GUI Frameworks</keyword>
      <keyword>Web Applications</keyword>
    </keywordset>
    <authorgroup>
    <author>
      <personname>
        <firstname>Krzysztof</firstname>
        <surname>Palacz</surname>
      </personname>
      <email>krzysztof.palacz@sun.com</email>
      <!-- <personblurb><para>Krzysztof Palacz is blah blah</para></personblurb>  -->
      <affiliation>
	<!--        <jobtitle>Staff Engineer</jobtitle> -->
        <org>
          <orgname>Sun Microsystems Laboratories</orgname>
	  <!--          <orgdiv></orgdiv> -->
          <address>
            <city>Menlo Park</city>
            <street>16 Network Circle</street>
	    <postcode>94025</postcode> 
	    <state>CA</state>
	    <country>USA</country>
          </address>   
        </org>
      </affiliation>
      
    </author>
    <author>
      <personname> <firstname>Dan</firstname> <surname>Ingalls</surname> </personname>
      <email>dan.ingalls@sun.com</email>
    </author>
    </authorgroup>

    <abstract>
      <para>
	
The Lively Kernel is a fully interactive, "zero-installation"
Web application framework and development environment and written
entirely in JavaScript. The rich user experience of applications built
using the Lively Kernel is enabled by integrated programmatic access
to arbitrary, dynamic 2D graphics, and owed in no small part to its
reliance on Scalable Vector Graphics and its bindings to the
JavaScript language.
</para>

<para>
Lively Kernel runs in SVG-enabled Web browsers without installation or
plug-in requirements; it offers a compact and extensible set of user
interface components, as a result, it supports familiar desktop-style
applications with the expected user interface functionality and direct
manipulation capabilities; it enables application development and
deployment in a Web browser with no installation or upgrades, using
only existing Web technologies. In addition to its application
execution capabilities, the Lively Kernel also functions as an
integrated development environment (IDE), as a result, it is
self-supporting and able to improve and extend itself
dynamically. Lively Kernel is currently also one of the most sizable
dynamic SVG frameworks available, and has become an important test
case for SVG implementations in Web browsers.
</para>

<para>
The main component of the Lively Kernel is a user interface framework
called Morphic, originally developed for the Self language, and later
incorporated into Squeak (a version of the Smalltalk programming
language). The Morphic framework consists of about 10,000 lines of
uncompressed JavaScript code downloaded to the Web browser on Lively
Kernel startup. The central goal of Morphic is to facilitate
construction and editing of graphical objects, both programmatically
and by direct, interactive manipulation. Morphic objects are editable,
composable and animatable, Morphic also handles user input and manages
underlying system resources such as fonts, gradients or
images. Built-in mechanisms are provided for object scaling, rotation,
object editing, as well as for defining user interface
themes. Currently, visual editing tools are provided for only a subset
of the elements defined in the SVG specification, however, our system
could be straightforwardly extended to act as a complete SVG authoring
tool.
</para>

<para>
The Morphic framework also provides a library of higher level user
interface components, such as buttons, lists, menus, windows, etc.,
composed from the basic graphical objects, as well as a
Model-View-Controller infrastructure for abstracting visual
representation of data from application logic. The default
configuration of the Lively Kernel offers a familiar desktop metaphor
with multiple applications running concurrently, however, standalone
applications are also supported.
</para>

<para>
The Morphic framework includes tools for development, modification and
deployment of applications from within the Lively Kernel system
itself. The tools include a class browser, an object inspector and a
DOM inspector. The implementation of these tools relies on the
reflective capabilities of JavaScript, and can therefore be used
inside the Web browser without any external tools or IDEs. As a
result, it is possible to, e.g., create new JavaScript classes, modify
or delete existing methods, or change the value of any property in the
system. Finally, it is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
</para>
</abstract>
</info>
<section>
<!-- stolen from the rejected ecoop paper -->
<title>Motivation</title>
<!-- AJAX platform -->

<para>There is no good reason for Web Programming to be more complicated, less general, or any less fun 
than desktop or other programming.  There are reasons, of course -- reasons that go back to missed 
opportunities when the web was designed -- but these need not hold us back.  In this paper we describe 
a simple and general kernel for programming the web.  It is less than 10,000 lines of code (with 
comments), it runs in major browsers with no installation, and it performs well.  We call it the Lively 
Kernel.
</para> 
<para>
We inherit from the World Wide Web an architecture built around a text markup language.  The Lively 
Kernel sets that architecture aside in favor of modern graphics and a dynamic programming language. 
We begin by turning the conventional we programming "stack" upside-down as shown in Figure 2. 
Figure 2:  Turning Web Programming Upside-Down
The first priority of this architecture is to provide a world of active objects.  This is accomplished by 
putting a dynamic language close to the operating system, which allows both the infrastructure 
(widgets, etc.) and the application to share the same pervasive generality and power.  The compactness 
and capability of our small system validates this approach. 
</para>

<remark>
<para>

 LK conceptually not tied to any graphics backend but SVG as a good
fit as an implementation technology, alternatives: canvas: no text,
silverlight, flex not open.
</para>
</remark>
<figure>
<mediaobject><imageobject>
<imagedata fileref="screenshot-small.jpg"/>
</imageobject></mediaobject>
<caption><para>Example instantiation of the Lively Kernel.</para></caption>
</figure>
<para>
This paper presents the SVG backend of the Lively Kernel. We have
found the SVG standard to be a great fit as our graphics substrate,
and its implementations in widely available Web browsers turned out to
be adequate to demonstrate the potential of our approach. While our
current work is almost exclusively built on top of the SVG backend, we
are vitally interested in portability to other graphics substrates.
In fact, an earlier version of our system provided a custom
browser-like environment on top of the Java platform, using Java2D
APIs as its graphics subsystem and Rhino as its execution engine.
</para>

</section>

<section>

<title>Morphic User Interface Framework</title>

<para>
The majority of the JavaScript classes defined by the Lively Kernel
are related to a user interface framework called Morphic. 


The central goal of Morphic is to facilitate construction and
modification of interactive graphical objects, both by direct
manipulation and by conventional programming.  The Morphic framework
was developed originally for the Self language and system
(<code>http://research.sun.com/self</code>), and later became popular
as the user interface of the Squeak system
(<code>http://www.squeak.org</code>). Lively Kernel reimplements a
sizable subset of the original Morphic framework in JavaScript using
technologies available in modern web browsers.
</para>

<para>
Morphic achieves simplicity and uniformity by defining and extensively
relying on a class of graphical objects called “morphs”, possessing
some or all of the following properties:
<itemizedlist mark='bullet'>
  <listitem> <para>
      A shape, or graphical appearance 
  </para> </listitem>
  <listitem> <para>
      A set of submorphs, comprising the “scene graph” of the page or world
  </para> </listitem>
  <listitem> <para>
      A coordinate transformation that affects its shape and any submorphs
  </para> </listitem>
  <listitem> <para>
      An event handler for mouse and keyboard events 
  </para> </listitem>
  <listitem> <para>
      An editor for changing its shape 
  </para> </listitem>
  <listitem> <para>
      A layout manager for laying out its submorphs 
  </para> </listitem>
  <listitem> <para>
      A stepping protocol for time-varying behavior 
  </para> </listitem>
  <listitem> <para> A damage rectangle repainting protocol and
      double-buffered display mechanism (used when the underlying
      graphics substrate does not provide it)
  </para> </listitem>
</itemizedlist>
</para>

<para>
Morphic defines several classes of morphs with special semantics.
A <code>WorldMorph</code> captures the notion of an entire web page;
its shape defines its background appearance, if any, and its submorphs
comprise all the remaining content of the page. In contrast to typical
web pages, however, multiple worlds can coexist in a single JavaScript
execution context. Notionally, the user interacts with the contents of
single world, and navigates between different worlds by clicking on
visual representations of connections between worlds,
called <code>LinkMorphs</code>.
</para>

<para>
A HandMorph is the Morphic generalization of a cursor; it can be used
to pick up, move, and deposit other morphs, its shape may change to
indicate different cursor states, and it is the source of user events
in the architecture.  In Lively Kernel, a Morphic world may have
several hands active at the same time, corresponding to several
collaborating users of that world (this functionality is not yet
available in the current incarnation of the Lively Kernel, however, it
has been implemented in an earlier prototype based on the Java
platform and Rhino scripting engine).
</para>

<remark>
Cover shape editors (-> full coverage of the SVG spec possible but not
implemented), widgets, MVC, tools (img of tilted code browser)
</remark>

</section>

<section>
<title>Implementing Morphic in SVG</title> 

<remark> the whole SVG tree is built dynamically. By default, the
entry point to the Lively Kernel runtime is a static document defining
only a single empty <code>&lt;svg&gt;</code> element, and the entire
SVG DOM tree of the running system is constructed programmatically
from JavaScript on system load.
</remark>

<programlisting><![CDATA[
319 Host Interface – Browser API plus XML utility functions 
515 Utility – Classes, collections, printing, etc. (plus 562 in Prototype.js) 
833 Basic Graphics – Point, Rectangle, Transform, Color, Gradient, Image 
550 Shapes – Host graphical objects (SVG node API) 
1667 Morph – Basic protocol 
1170 Morphic Core -- World, Hand, Event, Handles, Handlers 
1188 Basic Widgets – Button, List, Menu, Dialog, Slider, Selection, ImageMorph 
1921 Text – basic TextMorph plus composition and rich text 
747 Editors – Drag/drop manipulation, shape editors and text editing 
also ColorPicker and StylePanel 
386 Model, Widget 
1295 High Level Widgets – Scroll panes, panels, windows, world links 
also Panel and Browser support 
1311 Tools – Browser, inspector, stack viewer, change lists, profiler 
406 Serialization – Copier, exporter, importer (plus 202 in JSON) 
281 Network – URL, HTTP, WebDAV basics 
365 Storage – WebDAV, file browser 
----- ----- 
12954 Total 

Figure 10: Breakdown of Lively Kernel by function with approximate
code size The figures above include comments and lines with single
bracket characters.  Prototype.js is an open source set of useful
JavaScript extensions, of which we use only a small number [see
http://www.prototypejs.org/], [see http://www.JSON.org/].
]]></programlisting>


Imperative API for SVG, hiding the XML underpinnings and hence
portable to different architectures. API JS-centric (hence no XBL,
even though similar interest in reusable components).


<section>
<title>Containment</title>
<para>The Morphic framework organizes visual objects on the screen
using a tree of morphs. Each morph has a single owner morph and can
act as a container for other morphs. The SVG backend of Lively Kernel
naturally maps morphs onto SVG <code>&lt;g&gt;</code> elements. The
semantics of <code>&lt;g&gt;</code> elements corresponds well to the
semantics of Morphic, specifically, the nesting of
<code>&lt;g&gt;</code> elements is a means of logical organization and
does not imply visual containment, and submorphs are not necessarily
visualy contained inside their owner morphs, either. A morph's shape is
represented by one of the basic SVG shape elements, such
as <code>&lt;rect&gt;</code>, <code>&lt;ellipse&gt;</code>,
or <code>&lt;path&gt;</code>.
</para>

<para>Currently, Lively Kernel does not take advantage of the property
inheritance mechanism of <code>&lt;g&gt;</code> elements provided by
the SVG specification, and each basic shape element is required to specify the
full set of its visual attributes. This feature of the SVG standard
could be potentially taken advantage of, both as implementation
technique to improve space utilization, and as an API-level
programming abstraction (perhaps as a mechanism to specify widget
"skins").
</para>
</section>


<para>
The Lively Kernel SVG backend allocates a private
 <code>&lt;defs&gt;</code> element to every morph. The SVG
specification designates <code>&lt;defs&gt;</code> elements as
containers for elements that are not directly rendered on the screen,
such as gradients or clip paths. These elements are typically referred
to by URI attributes on other elements (the SVG standard makes
extensive use of URI references to express relations between elements
that are not captured by the DOM tree hierarchy). This design
facilitates space optimizations through sharing of commonly used
elements, however, Lively Kernel does not currently take advantage of
it. Instead, all the elements in a morph's <code>&lt;defs&gt;</code>
section are notionally owned by the morph, and the URIs of these elements are
trivially derived from the URI of the morph's <code>&lt;g&gt;</code>
element. As a result, every morph defines all the gradients it uses,
even though a typical user interface uses only a handful of distinct
gradient defintions that could be shared and applied to multiple
visual elements. This may be perceived as a shortcoming of the current
SVG backend, however, the current approach does simplify certain
implementation aspects, most notably copying and serialization of
individual morphs. We envision that a future version of our system could
implement gradient sharing, most likely based on a uniform reference
counting facility for all SVG elements referenced through URIs.
</para>

<!--What does it have to do with Lessphic? -->

<section> 
<title>The implementation of mapping: wrapping versus extending DOM elements</title>
<para>
There are at least two general approaches to implementing the mapping
of abstract tree data structures, such as the morph tree defined by
the Morphic API, to DOM trees. The first involves extending
appropriate DOM elements so that they <emphasis>become</emphasis>
morphs. This was the approach originally used by the Lively Kernel SVG
backend. Despite its conceptual simplicity, it required certain
non-obvious implementation techniques. For instance, while all morphs
were implemented as <code>&lt;g&gt;</code> elements, the converse was
not deemed appropriate: not all <code>&lt;g&gt;</code> elements
shouldx be morphs. In order to satisfy this requirement, morph factory
methods dynamically modified the inheriance chain
of <code>&lt;g&gt;</code> elements intended to become morphs, by
inserting a morph prototype object, defining the functionality shared
by all morphs. Such modifications are not possible according to the
ECMAScript language specification (an object's <code>prototype</code>
is not directly accessible programmatically), however, most JavaScript
implementations recognize this problem as a language limitation, and
make the object prototype accessible through a
mutable <code>__proto__</code> property that can be manipulated to
obtain the desired inheritance behavior. Unfortunately, this approach
eliminated the Opera browser from the list of potential Lively Kernel
platforms, since its JavaScript engine does not
implement <code>__proto__</code>.
</para>

<para>
A minor inconvenience of this approach was that new morphs were
instantiated using factory methods of the form <code>MyMorph()</code>,
instead of explicit allocation syntax, as in <code>new
MyMorph()</code> (as a side note, due to the semantics of JavaScript,
accidental insertion of the <code>new</code> keyword did not affect
the correctness of the program, but merely resulted in a wasteful
allocation of an unused object). A much more important limitation
turned out to be incompatibility with environments such as Batik
(FIXME cite?), which support the <code>__proto__</code> property but
do not allow extension of host objects (i.e., objects created and
managed outside of the JavaScript runtime, such as DOM objects, and
merely exposed programmatically to JavaScript).
</para>

<para>
In the face of the limitations, the subsequent reimplementation of the
Lively Kernel SVG backend uses a more conventional implementation
technique based on <emphasis>wrappers</emphasis>. Morphs are
implemented as regular, user-defined JavaScript objects furnished with
a <code>rawNode</code> property, pointing to the host object
representing the corresponding <code>&lt;g&gt;</code>
element. Similarly, <code>Shape</code> objects wrap simple SVG shape
elements referred to through their <code>rawNode</code> property. No
new properties or methods are added to host objects, and many Morph
and Shape methods simply delegate to the
underlying <code>rawNode</code>. Unfortunately, the object identity of
the Morph is now distinct from the identity of the
underlying <code>rawNode</code>, which requires additional boilerplate
code to map from Morphs to DOM objects. Interestingly, apart from
debugging, it is currently never necessary to find a corresponding
Morph given the DOM element that implements it, is due largely to the
fact that Lively Kernel performs its own mouse event delivery.

The technique itself is of course well known, in particular the Dojo
toolkit <remark>FIXME cite? </remark> uses a similar approach for its cross-platform graphics
library <code>dojo.gfx</code>, and Lively Kernel even borrows its
convention of naming the underlying DOM element <code>rawNode</code>.
</para>

</section> <!-- end of wrapping vs extending -->


<para>
Lively Kernel does not currently use several features of the SVG
specification. Most notably, it does not use declarative animations,
due to both lack of support in current browsers, and our interest in
portability of the implementation to other graphics backends. Instead,
a simple imperative framework for scheduling and periodic invocation
of user-supplied actions is provided. Document styling (through either
Cascading Style Sheets or Extensible Stylesheet Language standards) is
not currently used, either, although useful applications of styling
could be envisioned. For instance, styling could enable support for
different UI "skins", i.e., sets of visually coherent presentation
attributes that can be applied to a widget or application at the
user's discretion. Another platform feature not used by Lively Kernel
is mouse event delivery. Instead of registering event handlers on
individual SVG elements, the <code>HandMorph</code> registers a single
input event handler in the capture phase of DOM event delivery. The
handler determines the morph that should receive the event based on
the coordinates contained in the event object and and geometry
information obtained by inspecting the morph tree. Clearly, Lively
Kernel duplicates in JavaScript some of the mechanisms implemented
natively by the DOM, however, event delivery turns out not to be
performance-critical, and the resulting codebase is more easily
portable to graphics backends not based on a DOM.
</para>



</section>






<section>
<title>SVG as a component of an application description format</title>

Even with multiple graphics backends,
the serialization format could be either an entirely new format (and n
translations for n platforms), or an existing format like SVG with n-1
translations for the remaining n-1 platforms.
<!-- copied from abstract --> 
It is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.


</section>

<section>
<title>Experiences with SVG implementations</title> 

<remark>
Firefox, Safari, Batik, Examotion, Opera.  Better support highly
requested in the areas of drag and drop, copy and paste support,
filters for dropshadows. 
<para>Performance questions: efficiency of dynamic
update to the SVG tree; speed of bindings (height of the software layers between JS and the graphics engine).
</para>

</remark>
</section>

<bibliography xmlns="http://docbook.org/ns/docbook">
  <title>References</title>
  
  <biblioentry>
    <abbrev>LK-TR</abbrev>
    <authorgroup>
      <author><personname> <firstname>Antero</firstname><surname>Taivalsaari</surname> </personname></author>
      <author><personname> <firstname>Tommi</firstname><surname>Mikkonen</surname> </personname></author>
      <author><personname> <firstname>Dan</firstname><surname>Ingalls</surname> </personname></author>
      <author><personname> <firstname>Krzysztof</firstname><surname>Palacz</surname> </personname></author>
    </authorgroup>
    <title>Web Browser as an Application Platform: The Lively Kernel Experience.</title>
  </biblioentry>
  <biblioentry>
    Maloney, J. H. and Smith, R. B. 1995. Directness and liveness in
    the morphic user interface construction environment. In
    Proceedings of the 8th Annual ACM Symposium on User interface and
    Software Technology (Pittsburgh, Pennsylvania, United States,
    November 15 - 17, 1995). UIST '95. ACM, New York, NY, 21-28. DOI=
    http://doi.acm.org/10.1145/215585.215636
  </biblioentry>
  
</bibliography>


</article>
