<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://www.oasis-open.org/docbook/xml/5.0b5/rng/docbook.rng" type="xml"?>
<?xml-stylesheet type="text/xsl" href="http://docbook.sourceforge.net/release/xsl/current/xhtml/docbook.xsl"?>

<!-- 
     Safari will load this file and honor the stylesheet spec above.
     Alternatively, a simple, slow, offline way of generating html from the command line:

     $ xsltproc http://docbook.sourceforge.net/release/xsl/current/html/docbook.xsl paper.xml > paper.html.

-->
<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>The Lively Kernel Application Framework</title>
<!--    <subtitle></subtitle> -->
    <keywordset>
      <keyword>SVG</keyword>
      <keyword>GUI Frameworks</keyword>
      <keyword>Web Applications</keyword>
    </keywordset>
    <authorgroup>
    <author>
      <personname>
        <firstname>Krzysztof</firstname>
        <surname>Palacz</surname>
      </personname>
      <email>krzysztof.palacz@sun.com</email>
      <!-- <personblurb><para>Krzysztof Palacz is blah blah</para></personblurb>  -->
      <affiliation>
	<!--        <jobtitle>Staff Engineer</jobtitle> -->
        <org>
          <orgname>Sun Microsystems Laboratories</orgname>
	  <!--          <orgdiv></orgdiv> -->
          <address>
            <city>Menlo Park</city>
            <street>16 Network Circle</street>
	    <postcode>94025</postcode> 
	    <state>CA</state>
	    <country>USA</country>
          </address>   
        </org>
      </affiliation>
      
    </author>
    <author>
      <personname> <firstname>Dan</firstname> <surname>Ingalls</surname> </personname>
      <email>dan.ingalls@sun.com</email>
    </author>
    </authorgroup>

    <abstract>
      <para>
	
The Lively Kernel is a fully interactive, "zero-installation"
Web application framework and development environment and written
entirely in JavaScript. The rich user experience of applications built
using the Lively Kernel is enabled by integrated programmatic access
to arbitrary, dynamic 2D graphics, and owed in no small part to its
reliance on Scalable Vector Graphics and its bindings to the
JavaScript language.
</para>

<para>
Lively Kernel runs in SVG-enabled Web browsers without installation or
plug-in requirements; it offers a compact and extensible set of user
interface components, as a result, it supports familiar desktop-style
applications with the expected user interface functionality and direct
manipulation capabilities; it enables application development and
deployment in a Web browser with no installation or upgrades, using
only existing Web technologies. In addition to its application
execution capabilities, the Lively Kernel also functions as an
integrated development environment (IDE), as a result, it is
self-supporting and able to improve and extend itself
dynamically. Lively Kernel is currently also one of the most sizable
dynamic SVG frameworks available, and has become an important test
case for SVG implementations in Web browsers.
</para>

<para>
The main component of the Lively Kernel is a user interface framework
called Morphic, originally developed for the Self language, and later
incorporated into Squeak (a version of the Smalltalk programming
language). The Morphic framework consists of about 10,000 lines of
uncompressed JavaScript code downloaded to the Web browser on Lively
Kernel startup. The central goal of Morphic is to facilitate
construction and editing of graphical objects, both programmatically
and by direct, interactive manipulation. Morphic objects are editable,
composable and animatable, Morphic also handles user input and manages
underlying system resources such as fonts, gradients or
images. Built-in mechanisms are provided for object scaling, rotation,
object editing, as well as for defining user interface
themes. Currently, visual editing tools are provided for only a subset
of the elements defined in the SVG specification, however, our system
could be straightforwardly extended to act as a complete SVG authoring
tool.
</para>

<para>
The Morphic framework also provides a library of higher level user
interface components, such as buttons, lists, menus, windows, etc.,
composed from the basic graphical objects, as well as a
Model-View-Controller infrastructure for abstracting visual
representation of data from application logic. The default
configuration of the Lively Kernel offers a familiar desktop metaphor
with multiple applications running concurrently, however, standalone
applications are also supported.
</para>

<para>
The Morphic framework includes tools for development, modification and
deployment of applications from within the Lively Kernel system
itself. The tools include a class browser, an object inspector and a
DOM inspector. The implementation of these tools relies on the
reflective capabilities of JavaScript, and can therefore be used
inside the Web browser without any external tools or IDEs. As a
result, it is possible to, e.g., create new JavaScript classes, modify
or delete existing methods, or change the value of any property in the
system. Finally, it is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.
</para>
</abstract>
</info>
<section>
<!-- stolen from the rejected ecoop paper -->
<title>Motivation</title>


<para>There is no good reason for Web Programming to be more complicated, less general, or any less fun 
than desktop or other programming.  There are reasons, of course -- reasons that go back to missed 
opportunities when the web was designed -- but these need not hold us back.  In this paper we describe 
a simple and general kernel for programming the web.  It is less than 10,000 lines of code (with 
comments), it runs in major browsers with no installation, and it performs well.  We call it the Lively 
Kernel.
</para> 
<para>
We inherit from the World Wide Web an architecture built around a text markup language.  The Lively 
Kernel sets that architecture aside in favor of modern graphics and a dynamic programming language. 
We begin by turning the conventional we programming "stack" upside-down as shown in Figure 2. 
Figure 2:  Turning Web Programming Upside-Down
The first priority of this architecture is to provide a world of active objects.  This is accomplished by 
putting a dynamic language close to the operating system, which allows both the infrastructure 
(widgets, etc.) and the application to share the same pervasive generality and power.  The compactness 
and capability of our small system validates this approach. 
</para>

<remark>
<para>

 LK conceptually not tied to any graphics backend but SVG as a good
fit as an implementation technology, alternatives: canvas: no text,
silverlight, flex not open.
</para>
</remark>
<figure>
<mediaobject><imageobject>
<imagedata fileref="screenshot-small.jpg"/>
</imageobject></mediaobject>
<caption><para>Example instantiation of the Lively Kernel.</para></caption>
</figure>
<para>
This paper presents the SVG backend of the Lively Kernel. We have
found the SVG standard to be a great fit as our graphics substrate,
and its implementations in widely available Web browsers to be
adequate to demonstrate the potential of our approach. While our
current work is almost exclusively built on top of the SVG backend, we
are vitally interested in portability to other graphics substrates,
and, in fact, an earlier version of our system provided a custom
browser-like environment on top of the Java platform, using Java2D
APIs as its graphics subsystem and Rhino as its execution engine.
</para>

</section>

<section>
<!-- stolen from the rejected ecoop paper-->
<title>A quick summary of the Morphic architecture</title> 

The Morphic architecture aims to provide a simple and uniform graphics
 API.  It achieves this goal by defining a class of graphical objects,
 or “morphs”, possessing some or all of the following properties:
<itemizedlist mark='bullet'>
  <listitem> <para>
      A shape, or graphical appearance
  </para> </listitem>
  <listitem> <para>
      A set of submorphs, comprising the “scene graph” of the page or world
  </para> </listitem>
  <listitem> <para>
      A coordinate transformation that affects its shape and any submorphs
  </para> </listitem>
  <listitem> <para>
      An event handler for mouse and keyboard events 
  </para> </listitem>
  <listitem> <para>
      An editor for changing its shape 
  </para> </listitem>
  <listitem> <para>
      A layout manager for laying out its submorphs 
  </para> </listitem>
  <listitem> <para>
      A stepping protocol for time-varying behavior 
  </para> </listitem>
  <listitem> <para> A damage rectangle repainting protocol and
      double-buffered display mechanism when this is not available in
      the underlying graphics
  </para> </listitem>
</itemizedlist>

A WorldMorph captures the notion of an entire web page; its shape
defines its background appearance if any, and its submorphs comprise
all the remaining content of the page.  A HandMorph is the Morphic
generalization of the cursor; it can be used to pick up, move, and
deposit other morphs, its shape may change to indicate different
cursor states, and it is the source of user events in the
architecture.  In th Lively Kernel, a Morphic world may have several
hands active at the same time, corresponding to several collaborating
users of that world, and multiple worlds may be linked in the manner
of linked web pages.  Interested readers are referred to the original
papers on Morphic [see References], and to the Lively Kernel technical
documentation.
</section>

<section>
<title>Implementing Morphic in SVG</title> 

<section>
<title>Containment</title>
<para>The original Morphic UI framework organizes visual objects on
the screen using a tree of <emphasis>morphs</emphasis>. Each morph has
a single owner morph and can act as a container for other
morphs. Lively Kernel retains this architectural model, and its SVG
backend naturally maps morphs onto SVG <code>&lt;g&gt;</code>
elements. The semantics of <code>&lt;g&gt;</code> elements corresponds
well to that of Morphic, specifically, the nesting of
<code>&lt;g&gt;</code> elements does not imply visual containment, and submorphs
are not necessarily visualy contained by their owner morphs, either. A
morph's shape is represented by one of the basic SVG shape elements, such
as <code>&lt;rect&gt;</code>, <code>&lt;ellipse&gt;</code>, or <code>&lt;path&gt;</code>. 
</para>

<para>Currently, Lively Kernel does not take advantage of the property
inheritance mechanism of <code>&lt;g&gt;</code> elements provided by
the SVG spec, and each basic shape element is required to specify the
full set of its visual attributes. This feature of the SVG standard
could be potentially taken advantage of, both as implementation
technique to improve space utilization, and as an API-level
programming abstraction (perhaps as a mechanism to specify widget
"skins").
</para>
</section>


<remark>
<para>SVG is a DAG.
Mapping of paint servers and other leaf-ish elements (referred to by xlink references). 
Ownership model for paint servers (simplifies serialization, not good for space efficiency).
</para>
What does it have to do with Lessphic?
</remark>

<section> 
<title>The implementation of mapping: wrapping versus extending DOM elements</title>
<para>
There are at least two general approaches to mapping abstract tree
data structures (such as the morph tree defined by the Morphic API) to
DOM trees. The first involves extending appropriate DOM elements so
that they <emphasis>become</emphasis> Morphs. This was the approach
originally used by the Lively Kernel SVG backend. Despite its
conceptual simplicity, it required certain non-obvious implementation
tricks. For instance, while all morphs were implemented
as <code>&lt;g&gt;</code> elements, it was not desirable for
all <code>&lt;g&gt;</code> elements to be morphs. In order to satify
this requirement, morph factory methods dynamically modified the
inheriance chain of <code>&lt;g&gt;</code> elements intended to become
morphs, by inserting a morph prototype object, defining the
functionality shared by all morphs. Such modifications are not
possible in according to the ECMAScript language specification (an
object's <code>prototype</code> is not directly accessible
programmatically), however, most JavaScript implementations recognize
this problem as a language limitation, and furnish every object with a
mutable <code>__proto__</code> property, which can be manipulated to
obtain the desired inheritance behavior. Unfortunately, this approach
eliminated the Opera browser from the list of potential Lively Kernel
platforms, since its JavaScript implementation does not
implement <code>__proto__</code>.
</para>

<para>
A minor inconvenience of this approach was that new morphs were
instantiated using factory methods (of the
form <code>MyMorph()</code>), instead of explicit allocation syntax,
as in <code>new MyMorph()</code> (as a side note, due to the semantics
of JavaScript, accidental insertion of the <code>new</code> keyword
did not affect correctness of the program, but merely resulted in a
wasteful allocation of an unused object). A much more important
limitation of the approach turned out to be incompatibility with
environments such as Batik (FIXME cite?), which support
the <code>__proto__</code> property but do not allow extension of host
objects (i.e., objects created and managed outside of the JavaScript
runtime, e.g., DOM objects, and merely exposed programmaticaly to JavaScript).
</para>

<para>
In the face of the limitations, a more
conventional <emphasis>wrapper</emphasis> - based technique was
employed in the subsequent reimplementation of the Lively Kernel SVG
backend. Morphs are implemented as regular, user-defined JavaScript
objects furnished with the <code>rawNode</code> property, pointing to
the host object representing the corresponding <code>&lt;g&gt;</code>
element. Similarly, <code>Shape</code> objects wrap simple SVG shape
elements referred to through their <code>rawNode</code> property. No
new properties or methods are added to host objects, and many Morph
and Shape methods simply delegate to the
underlying <code>rawNode</code>. Unfortunately, the object identity of
the Morph is now distinct from the identity of the
underlying <code>rawNode</code>, which requires additional boilerplate
code to map from Morphs to DOM objects (interestingly, apart from
debugging, it is currently never necessary to find a corresponding
Morph given the DOM element that implements it, is due largely to the
fact that Lively Kernel performs its own mouse event delivery).

The technique itself is of course well known, in particular the Dojo
toolkit uses a similar approach for its cross platform graphics
library <code>dojo.gfx</code>, and Lively Kernel even borrows its
convention of naming the underlying DOM element <code>rawNode</code>.
</para>

</section> <!-- end of wrapping vs extending -->


<remark>
<para>Declarative vs imperative animations: the underlying graphics
substrate not guaranteed to have native declarative animation support - imperative animation.
</para>

<para>CSS styling not used.</para>

<para>DOM mouse event delivery not used.</para>
<!-- unused but useful parts of the SVG spec? -->
</remark>
</section>



<section>
<title>Lively Kernel as a Graphics Kernel</title> 

Imperative API for
SVG, hiding the XML underpinnings and hence portable to different
architectures. API JS-centric (hence no XBL, even though similar interest in reusable components).


<programlisting><![CDATA[
319 Host Interface – Browser API plus XML utility functions 
515 Utility – Classes, collections, printing, etc. (plus 562 in Prototype.js) 
833 Basic Graphics – Point, Rectangle, Transform, Color, Gradient, Image 
550 Shapes – Host graphical objects (SVG node API) 
1667 Morph – Basic protocol 
1170 Morphic Core -- World, Hand, Event, Handles, Handlers 
1188 Basic Widgets – Button, List, Menu, Dialog, Slider, Selection, ImageMorph 
1921 Text – basic TextMorph plus composition and rich text 
747 Editors – Drag/drop manipulation, shape editors and text editing 
also ColorPicker and StylePanel 
386 Model, Widget 
1295 High Level Widgets – Scroll panes, panels, windows, world links 
also Panel and Browser support 
1311 Tools – Browser, inspector, stack viewer, change lists, profiler 
406 Serialization – Copier, exporter, importer (plus 202 in JSON) 
281 Network – URL, HTTP, WebDAV basics 
365 Storage – WebDAV, file browser 
----- ----- 
12954 Total 

Figure 10: Breakdown of Lively Kernel by function with approximate
code size The figures above include comments and lines with single
bracket characters.  Prototype.js is an open source set of useful
JavaScript extensions, of which we use only a small number [see
http://www.prototypejs.org/], [see http://www.JSON.org/].
]]></programlisting>
</section>

<section>
<title>SVG as a component of an application description format</title>

Even with multiple graphics backends,
the serialization format could be either an entirely new format (and n
translations for n platforms), or an existing format like SVG with n-1
translations for the remaining n-1 platforms.
<!-- copied from abstract --> 
It is possible to dynamically export and import
objects or entire Web pages from within a running system and thus use
the Lively Kernel as an authoring environment both code and
interactive graphics. The export mechanism currently uses our own
implementation of the Distributed Authoring and Versioning (WebDAV)
extensions built on top of asynchronous HTTP networking support
present in all the modern browsers. Objects are serialized into valid
SVG files with additional Lively Kernel-specific annotations necessary
to reconstruct all the JavaScript objects on deserialization. The
annotations are placed in a dedicated XML namespace, as a result, if a
Lively Kernel runtime is not available at deserialization time or the
user agent does not support JavaScript, the serialized file is
rendered as a static screenshot of the application at the time of
serialization.


</section>

<section>
<title>Experiences with SVG implementations</title> 

<remark>
Firefox, Safari, Batik, Examotion, Opera.  Better support highly
requested in the areas of drag and drop, copy and paste support,
filters for dropshadows. 
<para>Performance questions: efficiency of dynamic
update to the SVG tree; speed of bindings (height of the software layers between JS and the graphics engine).
</para>

</remark>
</section>

<bibliography xmlns="http://docbook.org/ns/docbook">
  <title>References</title>
  
  <biblioentry>
    <abbrev>LK-TR</abbrev>
    <authorgroup>
      <author><personname> <firstname>Antero</firstname><surname>Taivalsaari</surname> </personname></author>
      <author><personname> <firstname>Tommi</firstname><surname>Mikkonen</surname> </personname></author>
      <author><personname> <firstname>Dan</firstname><surname>Ingalls</surname> </personname></author>
      <author><personname> <firstname>Krzysztof</firstname><surname>Palacz</surname> </personname></author>
    </authorgroup>
    <title>Web Browser as an Application Platform: The Lively Kernel Experience.</title>
  </biblioentry>
  <biblioentry>
    Maloney, J. H. and Smith, R. B. 1995. Directness and liveness in
    the morphic user interface construction environment. In
    Proceedings of the 8th Annual ACM Symposium on User interface and
    Software Technology (Pittsburgh, Pennsylvania, United States,
    November 15 - 17, 1995). UIST '95. ACM, New York, NY, 21-28. DOI=
    http://doi.acm.org/10.1145/215585.215636
  </biblioentry>
  
</bibliography>


</article>
